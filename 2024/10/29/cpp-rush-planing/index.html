
<!DOCTYPE html>
<html lang="zh-CN">
    <!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  
    <link rel="icon" href="/img/favicon.ico">
  
  
      <meta name="author" content="Lyana-nullptr">
  
  
      <meta name="subtitle" content="不知壹乎生，小阁思常在。">
  
  
      <meta name="description" content="不知壹乎生，小阁思常在。">
  
  
      <meta name="keywords" content=",Blog, 个人博客, 技术博客, 生活博客">
  
  
    <link rel="alternate" href="/atom.xml " title="Family Of Lyana" type="application/atom+xml">
  

  

  <title>C++ 冲刺计划（Java 版） | Family Of Lyana</title>

  

  

  

  <link rel="stylesheet" href="/css/style.css" >
  <link rel="stylesheet" href="/css/partial/dark.css" >

  
  
  

  
    
      <link rel="stylesheet" href="/css/partial/highlight/atom-one-light.css">
    
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css">
    
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css">
    
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/a2396837/CDN@latest/css/iconfont.css">
    
  

  
    <script src="/js/todark.js"></script>
    
<meta name="generator" content="Hexo 7.2.0"></head>
</html>
    
<div class="nav index" style="height: 60px;">
    <div class="title animated fadeInDown">
        <div class="layui-container">
                <div class="nav-title"><a href="/" title="Family Of Lyana">Family Of Lyana</a></div>
            <div class="nav-list">
                <button> <span class=""></span><span style="display: block;"></span><span class=""></span> </button>
                <ul class="layui-nav" lay-filter="">
                    
                        
                        
                        
                        
                    <li class="layui-nav-item">
                        <a href="/ ">
                            <i class=" fab fa-fort-awesome " style="color: rgb(255 107 107);"></i>
                            <span class="layui-nav-item-name">首页</span>
                        </a>
                    </li>
                    
                        
                        
                        
                        
                    <li class="layui-nav-item">
                        <a href="/archives/ ">
                            <i class=" fas fa-archive " style="color: rgb(10 189 227);"></i>
                            <span class="layui-nav-item-name">归档</span>
                        </a>
                    </li>
                    
                        
                        
                        
                        
                    <li class="layui-nav-item">
                        <a href="/tags/ ">
                            <i class=" fas fa-hashtag " style="color: rgb(254 202 87);"></i>
                            <span class="layui-nav-item-name">标签</span>
                        </a>
                    </li>
                    
                        
                        
                        
                        
                    <li class="layui-nav-item">
                        <a href="/categories/ ">
                            <i class=" far fa-folder-open " style="color: rgb(29 209 161);"></i>
                            <span class="layui-nav-item-name">分类</span>
                        </a>
                    </li>
                    
                        
                        
                        
                        
                    <li class="layui-nav-item">
                        <a href="/about/ ">
                            <i class=" fab fa-grav " style="color: rgb(154 106 247);"></i>
                            <span class="layui-nav-item-name">关于</span>
                        </a>
                    </li>
                    
                        
                        
                        
                        
                    <li class="layui-nav-item">
                        <a href="/guestbook/ ">
                            <i class=" fab fa-telegram " style="color: hsl(205deg 100% 50%);"></i>
                            <span class="layui-nav-item-name">留言</span>
                        </a>
                    </li>
                    
                    
                        <li class="layui-nav-item" id="btn-toggle-dark">🌙</li>
                    
                    <span class="layui-nav-bar" style="left: 342px; top: 78px; width: 0px; opacity: 0;"></span>
                </ul>
            </div>
        </div>
    </div>
</div>
    
<header class="header">
        
            <div class="logo">
                    <a href="/"><img src="https://avatars.githubusercontent.com/u/51262009" onerror=this.onerror=null,this.src="/img/loading.gif"></a>
            </div>
         
    </div>
     

            <div class="motto">
                <span>和明天说你好！OvO</span>
            </div>
    
    
            <div class="social">
                
                        <a class="social-icon" href="https://github.com/Lyana-nullptr" target="_blank" title="Github">
                            <i class="iconfont icon-GitHub" aria-hidden="true"></i>
                          </a>
                 
                        <a class="social-icon" href="mailto:shabbyacc@outlook.com" target="_blank" title="Email">
                            <i class="iconfont icon-email" aria-hidden="true"></i>
                          </a>
                 
                        <a class="social-icon" href="https://steamcommunity.com/id/the-most-handsome-man" target="_blank" title="Steam">
                            <i class="iconfont icon-steam" aria-hidden="true"></i>
                          </a>
                 
                        <a class="social-icon" href="https://space.bilibili.com/552355730" target="_blank" title="Bilibili">
                            <i class="iconfont icon-bilibili" aria-hidden="true"></i>
                          </a>
                 
                        <a class="social-icon" href="https://music.163.com/#/user/home?id=564549068" target="_blank" title="Netmusic">
                            <i class="iconfont icon-wangyiyunyinle1" aria-hidden="true"></i>
                          </a>
                 
                        <a class="social-icon" href="/atom.xml" target="_blank" title="rss">
                            <i class="iconfont icon-rss" aria-hidden="true"></i>
                          </a>
                 
            </div>
     
</header>

    
<article id="post">
  <div class="post-title">C++ 冲刺计划（Java 版）</div>
  
<div class="post-meta">
    
    
      <div class="post-meta-item date">
        <span title="发表于 2024.10.29"><i class="far fa-calendar-alt"></i> 2024.10.29</span>
      </div>
      <div class="post-meta-item updated">
        <span title="更新于 2024.11.02"><i class="far fa-calendar-check"></i> 2024.11.02</span>
      </div>
     
    
      <div class="post-meta-item categories">
        
          <i class="fas fa-inbox article-meta__icon"></i> <a href="/categories/%E5%86%B2%E5%88%BA%E8%AE%A1%E5%88%92/">冲刺计划</a>
        
          <i class="fas fa-inbox article-meta__icon"></i> <a href="/categories/%E5%86%B2%E5%88%BA%E8%AE%A1%E5%88%92/C/">C++</a>
        
      </div>
     
    
     <div class="post-meta-item wordcount">
        
          <i class="fas fa-pencil-alt"></i> <span class="post-count">18.9k 字</span>
           
        
          <i class="far fa-clock"></i> <span class="post-count">75 分钟</span>
                               
      </div>
     
</div>


  
    <div id="toc" class="toc">
          <h1>目录</h1>
          <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E7%82%B9%E7%9F%A5%E8%AF%86%E7%9B%AE%E5%BD%95"><span class="toc-number">1.</span> <span class="toc-text">重点知识目录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">C++ 的工作流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8F"><span class="toc-number">3.</span> <span class="toc-text">宏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E7%BC%96%E8%AF%91%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-number">4.</span> <span class="toc-text">预编译头文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.</span> <span class="toc-text">数据类型**</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.1.</span> <span class="toc-text">字符类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">6.</span> <span class="toc-text">隐式类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">7.</span> <span class="toc-text">显式类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">8.</span> <span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">8.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%EF%BC%88%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%89"><span class="toc-number">8.2.</span> <span class="toc-text">创建（和初始化）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%8F%98%E9%87%8F%E5%88%9B%E5%BB%BA%E8%AF%AD%E6%B3%95"><span class="toc-number">8.3.</span> <span class="toc-text">常见变量创建语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%86%85%E5%AD%98%E4%BD%8D%E7%BD%AE"><span class="toc-number">8.4.</span> <span class="toc-text">作用域、生命周期和内存位置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F"><span class="toc-number">9.</span> <span class="toc-text">常量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-1"><span class="toc-number">9.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">9.2.</span> <span class="toc-text">创建和初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%B8%B8%E9%87%8F%E5%88%9B%E5%BB%BA%E8%AF%AD%E6%B3%95"><span class="toc-number">9.3.</span> <span class="toc-text">常见常量创建语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%86%85%E5%AD%98%E4%BD%8D%E7%BD%AE-1"><span class="toc-number">9.4.</span> <span class="toc-text">作用域、生命周期和内存位置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">10.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-2"><span class="toc-number">10.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E"><span class="toc-number">10.2.</span> <span class="toc-text">声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">10.3.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-number">10.4.</span> <span class="toc-text">参数传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-number">10.5.</span> <span class="toc-text">内联函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-number">11.</span> <span class="toc-text">指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-3"><span class="toc-number">11.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96-1"><span class="toc-number">11.2.</span> <span class="toc-text">创建和初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">11.3.</span> <span class="toc-text">智能指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">11.4.</span> <span class="toc-text">函数指针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-number">12.</span> <span class="toc-text">引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-4"><span class="toc-number">12.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96-2"><span class="toc-number">12.2.</span> <span class="toc-text">创建和初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E5%92%8C%E6%8C%87%E9%92%88"><span class="toc-number">12.3.</span> <span class="toc-text">引用和指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E5%92%8C%E5%87%BD%E6%95%B0"><span class="toc-number">12.4.</span> <span class="toc-text">引用和函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-number">13.</span> <span class="toc-text">枚举和枚举类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">14.</span> <span class="toc-text">类和结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-5"><span class="toc-number">14.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E-1"><span class="toc-number">14.2.</span> <span class="toc-text">声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">14.3.</span> <span class="toc-text">实例化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">14.4.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="toc-number">14.5.</span> <span class="toc-text">初始化列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">14.6.</span> <span class="toc-text">析构函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">14.7.</span> <span class="toc-text">拷贝构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">14.8.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">14.9.</span> <span class="toc-text">虚函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">14.10.</span> <span class="toc-text">纯虚函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84-array"><span class="toc-number">15.</span> <span class="toc-text">数组 array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%91%E9%87%8F-vector"><span class="toc-number">16.</span> <span class="toc-text">向量 vector</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-6"><span class="toc-number">16.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E9%87%8F%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96"><span class="toc-number">16.2.</span> <span class="toc-text">向量使用优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E7%BB%84-pair-%E5%92%8C%E5%85%83%E7%BB%84-tuple"><span class="toc-number">17.</span> <span class="toc-text">对组 pair 和元组 tuple*</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lambda-%E5%87%BD%E6%95%B0"><span class="toc-number">18.</span> <span class="toc-text">Lambda 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF"><span class="toc-number">19.</span> <span class="toc-text">模板</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-7"><span class="toc-number">19.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0"><span class="toc-number">19.2.</span> <span class="toc-text">模板函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E7%B1%BB"><span class="toc-number">19.3.</span> <span class="toc-text">模板类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">20.</span> <span class="toc-text">命名空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#static-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">21.</span> <span class="toc-text">static 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">21.1.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F-%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0"><span class="toc-number">21.2.</span> <span class="toc-text">静态全局变量&#x2F;静态函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">21.3.</span> <span class="toc-text">静态局部变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">21.4.</span> <span class="toc-text">静态成员变量&#x2F;静态成员函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">22.</span> <span class="toc-text">const 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8-1"><span class="toc-number">22.1.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F-1"><span class="toc-number">22.2.</span> <span class="toc-text">常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AA%E8%AF%BB%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">22.3.</span> <span class="toc-text">只读成员函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#extern-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">23.</span> <span class="toc-text">extern 关键字**</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">23.1.</span> <span class="toc-text">外部变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mutable-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">24.</span> <span class="toc-text">mutable 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8-2"><span class="toc-number">24.1.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E6%94%B9%E5%8F%98%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">24.2.</span> <span class="toc-text">可改变成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E6%94%B9%E5%8F%98%E7%9A%84-Lambda-%E5%87%BD%E6%95%B0%E6%8D%95%E8%8E%B7%E5%8F%98%E9%87%8F"><span class="toc-number">24.3.</span> <span class="toc-text">可改变的 Lambda 函数捕获变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#explicit-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">25.</span> <span class="toc-text">explicit 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8-3"><span class="toc-number">25.1.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A6%81%E6%AD%A2%E9%9A%90%E5%BC%8F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">25.2.</span> <span class="toc-text">禁止隐式构造函数类型转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E5%BA%93"><span class="toc-number">26.</span> <span class="toc-text">外部库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-8"><span class="toc-number">26.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93"><span class="toc-number">26.2.</span> <span class="toc-text">静态链接库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93"><span class="toc-number">26.3.</span> <span class="toc-text">动态链接库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E4%B8%8E%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">26.4.</span> <span class="toc-text">静态链接与动态链接的比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E4%B8%8E%E5%A0%86%E5%86%85%E5%AD%98%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">27.</span> <span class="toc-text">栈与堆内存的比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%8F%8C%E5%85%B3%EF%BC%88%E5%8E%9F%E5%A7%8B%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C%EF%BC%89"><span class="toc-number">28.</span> <span class="toc-text">类型双关（原始内存操作）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%94%E5%90%88%E4%BD%93"><span class="toc-number">29.</span> <span class="toc-text">联合体</span></a></li></ol>
      </div>
    
  <div class="content">
        <div><h2 id="重点知识目录"><a href="#重点知识目录" class="headerlink" title="重点知识目录"></a>重点知识目录</h2><p>本文基于视频 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1uy4y167h2">Cherno C++ 教程【中字】</a>。</p>
<p>其中，标有 * 的表示可能非重点，了解即可。标有 ** 的表示未完成。</p>
<p>搜索“原则”可以快速查找 C++ 编程应遵守的各种规范。</p>
<p>更清晰的 C++ 语法定义，见 <a target="_blank" rel="noopener" href="https://zh.cppreference.com/">CPP Reference 官网</a>。</p>
<ul>
<li><a href="#C++-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B">C++ 的工作流程</a> 5~7</li>
<li><a href="#%E5%AE%8F">宏</a> 55</li>
<li><a href="#%E9%A2%84%E7%BC%96%E8%AF%91%E5%A4%B4%E6%96%87%E4%BB%B6">预编译头文件</a> 72</li>
<li><a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B**">数据类型**</a></li>
<li><a href="#%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">隐式类型转换</a></li>
<li><a href="#%E6%98%BE%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">显式类型转换</a> 69</li>
<li><a href="#%E5%8F%98%E9%87%8F">变量</a> 8</li>
<li><a href="#%E5%B8%B8%E9%87%8F">常量</a></li>
<li><a href="#%E5%87%BD%E6%95%B0">函数</a> 9</li>
<li><a href="#%E6%8C%87%E9%92%88">指针</a> 16，44，58</li>
<li><a href="#%E5%BC%95%E7%94%A8">引用 </a>17</li>
<li><a href="#%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%9E%9A%E4%B8%BE%E7%B1%BB">枚举和枚举类</a> 24</li>
<li><a href="#%E7%B1%BB%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93">类和结构体</a> 18~20，25~29，38，45</li>
<li><a href="#%E6%95%B0%E7%BB%84-array">数组 array</a> 57</li>
<li><a href="#%E5%90%91%E9%87%8F-vector">向量 vector</a> 47~48</li>
<li><a href="#%E5%AF%B9%E7%BB%84-pair-%E5%92%8C%E5%85%83%E7%BB%84-tuple*">对组 pair 和元组 tuple*</a> 52</li>
<li><a href="#Lambda-%E5%87%BD%E6%95%B0">Lambda 函数</a> 59</li>
<li><a href="#%E6%A8%A1%E6%9D%BF">模板</a> 53</li>
<li><a href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">命名空间</a> 61</li>
<li><a href="#static-%E5%85%B3%E9%94%AE%E5%AD%97">static 关键字</a> 21~23</li>
<li><a href="#const-%E5%85%B3%E9%94%AE%E5%AD%97">const 关键字</a> 34</li>
<li><a href="#extern-%E5%85%B3%E9%94%AE%E5%AD%97**">extern 关键字**</a></li>
<li><a href="#mutable-%E5%85%B3%E9%94%AE%E5%AD%97">mutable 关键字</a> 35</li>
<li><a href="#explicit-%E5%85%B3%E9%94%AE%E5%AD%97">explicit 关键字</a> 40</li>
<li><a href="#%E5%A4%96%E9%83%A8%E5%BA%93">外部库</a> 49~51</li>
<li><a href="#%E6%A0%88%E4%B8%8E%E5%A0%86%E5%86%85%E5%AD%98%E7%9A%84%E6%AF%94%E8%BE%83">栈与堆内存的比较</a> 54</li>
<li><a href="#%E7%B1%BB%E5%9E%8B%E5%8F%8C%E5%85%B3%EF%BC%88%E5%8E%9F%E5%A7%8B%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C%EF%BC%89">类型双关（原始内存操作）</a> 66</li>
<li><a href="#%E8%81%94%E5%90%88%E4%BD%93">联合体</a> 67</li>
<li>线程 62</li>
</ul>
<h2 id="C-的工作流程"><a href="#C-的工作流程" class="headerlink" title="C++ 的工作流程"></a>C++ 的工作流程</h2><p>C++ 是一门编程语言，作为一个工具性质的产物，它的目的是生产出适用于各个平台的可执行程序或库文件。</p>
<p>在使用文本编辑器或集成开发环境编写完源代码后，我们会将源代码交给编译器生成可执行文件。<strong>生成可执行文件</strong>的过程实际分为三步：</p>
<ul>
<li><strong>预处理：</strong>在正式开始编译之前，预处理器会根据预处理语句（以 <code>#</code> 开头的语句）对每个<u>源文件</u> <code>.cpp</code> 做文本处理。预处理完成后的<u>源文件</u>将会交给编译器，真正开始编译。</li>
<li><strong>编译：</strong>编译器将每一个预处理后的源文件当做一个<u>翻译单元</u>，把其中的代码编译为目标平台的机器码，同时把静态变量和全局变量提取到数据段，存储在单独的<u>目标文件</u> <code>.obj</code> 或 <code>.o</code> 中，交由链接器进行链接。</li>
<li><strong>链接</strong>：一个目标文件或库文件可能使用了另一个目标文件或库文件的<u>符号</u>（Symbol，即标识符）定义，然而每一个文件在编译完成后都是单独的，它们无法直接互相访问。因此，链接器在解析目标文件和库文件时，如果发现目标文件或库文件中<u>使用了或可能使用</u>另一个目标文件或库文件的符号定义，它就会把这个符号的声明和定义链接在一起，使得符号能够正常使用。通过链接，链接器将所有的目标文件以及库文件合并成一个完整的可执行程序。</li>
</ul>
<blockquote>
<p><strong>备注：</strong></p>
<ol>
<li><p>如果没有设置预编译头文件，头文件不会被直接编译，而是加入源文件中，作为源文件的一部分被编译。</p>
</li>
<li><p>对于函数来说，符号指的是整个函数签名；对于全局变量来说，符号指的是变量名称和类型；对于类和结构体来说，符号指的是它们的名称……当然，<a href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">命名空间</a>是另一个话题了。要注意的是，符号不能重复定义，这也是<u>变量、函数不能重复定义的根本原因</u>。</p>
</li>
<li><p>要注意的是，即使我们的项目只有一个目标文件，C++ 运行时库也需要使用程序的入口点函数，因此生成可执行文件的过程中必然存在链接过程。</p>
</li>
</ol>
</blockquote>
<h2 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h2><p>在<strong>预处理阶段</strong>，我们可以使用宏来对我们源文件中的代码进行文本替换。宏在调试场景（如日志打印系统）中使用的比较多。</p>
<p>定义在头文件中的宏可以对所有导入它的源文件生效，过度使用宏会使得代码的可读性很差。<strong>因此，我们应该遵守一个原则：不要过度使用宏。</strong></p>
<p>宏定义中可以使用转义字符，我们可以使用<u>转义换行符</u>的方式实现多行的宏定义。</p>
<p>有关宏操作的几个预处理语句：</p>
<ul>
<li><p><strong>#define：</strong>宏定义语句。定义一个宏，预处理器将跟据宏的定义进行文本替换。</p>
</li>
<li><p><strong>#if、#elif、#else：</strong>分支语句。若条件为真，保留其下的所有文本；若条件为假，移除这些文本。</p>
</li>
<li><p><strong>#ifdef：</strong>分支语句，<code>#if defined</code> 的简化版。如果一个宏定义过，保留其下的所有文本；如果这个宏未定义过，移除这些文本。</p>
</li>
<li><p><strong>#ifndef：</strong>与 <code>#ifdef</code> 相反。</p>
</li>
<li><p><strong>#endif：</strong>用来结束分支语句，帮助划分文本范围。</p>
</li>
</ul>
<blockquote>
<p><strong>备注：</strong></p>
<ol>
<li><p>“其下的所有文本”指从该分支语句的下一行起，至下一个分支语句的前一行结束。</p>
</li>
<li><p><code>#if</code>、<code>#elif</code> 语句可以配合参数 <code>defined</code> 来实现判断一个宏是否被定义。</p>
</li>
</ol>
</blockquote>
<p>一个简单的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多行宏定义，反斜杠后面必须紧跟着回车</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAIN int main()\</span></span><br><span class="line"><span class="meta">&#123;\</span></span><br><span class="line"><span class="meta">    LOG(<span class="string">&quot;Hello!&quot;</span>);\</span></span><br><span class="line"><span class="meta">    LOGX(<span class="string">&quot;Hello!&quot;</span>);\</span></span><br><span class="line"><span class="meta">\</span></span><br><span class="line"><span class="meta">    std::cin.get();\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HW_DEBUG 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 较好的定义方式</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> HW_DEBUG == 1 <span class="comment">// 如果条件 HW_DEBUG == 1 满足，则</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGX(x) std::cout &lt;&lt; x &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> HW_DEBUG == 2 <span class="comment">// 否则如果条件 HW_DEBUG == 2 满足，则</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGX(x) std::cout &lt;&lt; <span class="string">&quot;value: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">// 否则</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGX(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// 用来结束分支语句 #else</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HW_DEBUG</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 常见的定义方式</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HW_DEBUG <span class="comment">// 如果定义了宏 HW_DEBUG，则</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(x) std::cout &lt;&lt; x &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined HW_DEBUGX <span class="comment">//或者定义了宏 HW_DEBUGX，则</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(x) std::cout &lt;&lt; <span class="string">&quot;value: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">// 否则</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// 用来结束分支语句 #else</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用多行宏定义 MAIN，等价于：</span></span><br><span class="line"><span class="comment">//int main()</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">// 	  LOG(&quot;Hello!&quot;);</span></span><br><span class="line"><span class="comment">//    LOGX(&quot;Hello!&quot;);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    std::cin.get();</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">MAIN</span><br></pre></td></tr></table></figure>

<h2 id="预编译头文件"><a href="#预编译头文件" class="headerlink" title="预编译头文件"></a>预编译头文件</h2><p>在大型的 C++ 项目中，每个源文件通常会包含许多公共的头文件（如标准库、第三方库头文件），这些头文件很少改变，我们希望它们在没有改变时不编译，从而提升编译过程的速度。这就需要对头文件进行预编译。</p>
<p>同时，在预处理阶段，虽然我们通过预处理语句能够保证最终结果是一个头文件只执行一次包含，但对预处理器而言，它依然需要一次一次地重复<strong>读取和解析</strong>这些头文件，判断它们是否需要被包含。这会花费很长的时间，拖慢编译的速度。通过预编译头文件，我们能够跳过重复预处理的步骤，提升编译过程的速度。</p>
<p>通过<strong>预编译头文件</strong>的方式，我们能够实现项目编译的提速。</p>
<p>当然使用预编译头文件可能导致我们不清楚一个源文件到底使用了哪些具体的头文件，<strong>因此我们应该遵守一个原则：只把那些非常经常使用的头文件加入预编译头文件中，</strong>例如 <code>iostream</code>、<code>string</code>、<code>Windows.h</code> 等。</p>
<p>使用 <u>Visual Studio</u> 构建项目时实现预编译头文件：</p>
<ol>
<li>创建一个预编译头文件 <code>pch.h</code>，将需要预编译的头文件包含语句写在其中。</li>
<li>创建对应的源文件 <code>pch.cpp</code>，并包含这个预编译头文件。</li>
<li>右键 <code>pch.cpp</code>，将“属性 -&gt; C&#x2F;C++ -&gt; 预编译头 -&gt; 预编译头”设置为“创建”。</li>
<li>右键项目，将“属性 -&gt; C&#x2F;C++ -&gt; 预编译头 -&gt; 预编译头”设置为“使用”，将同界面中的“预编译头文件”设置成 <code>pch.h</code>。</li>
</ol>
<blockquote>
<p><strong>备注：</strong></p>
<ol>
<li>不要将经常改变的头文件加入预编译，否则每次编译项目时，预编译的头文件都需要重新编译。这就失去了预编译的意义。</li>
<li>预编译头文件的名称可以是任意的，取决于自己。</li>
</ol>
</blockquote>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型**"></a>数据类型**</h2><h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><p>字符类型有如下几种：</p>
<ul>
<li><p><strong>char：</strong>存储 1 字节的字符（UTF-8）。</p>
</li>
<li><p><strong>wchar_t：</strong>存储宽字符，通常是 2~4 字节，取决于平台和编译器。</p>
</li>
<li><p><strong>char16_t：</strong>存储 2 字节的字符（UFTF-16）。</p>
</li>
<li><p><strong>char32_t：</strong>存储4字节的字符（UTF-32）。</p>
</li>
</ul>
<h2 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h2><p>C++ 中，允许变量赋值时进行一次<strong>隐式类型转换</strong>。包括：<u>基本数据类型间</u>的转换、<u>数组与指针</u>的类型转换、<u>函数与指针</u>的类型转换、使用<u>构造函数</u>的类型转换、使用<u>类型转换运算符</u>的类型转换。</p>
<ul>
<li><strong>基本数据类型间：</strong>略。</li>
<li><strong>数组与指针：</strong>把一个数组赋值给指针时，会隐式完成类型转换，因为数组变量自身就是一个存储着地址的变量。</li>
<li><strong>函数与指针：</strong>把一个函数赋值给指针时，会隐式使用取地址操作符进行类型转换。</li>
<li><strong>使用构造函数：</strong>使用构造函数所接受的参数赋值一个类或结构体类型的变量时，会隐式使用构造函数进行类型转换，详见<a href="#%E7%A6%81%E6%AD%A2%E9%9A%90%E5%BC%8F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">下文</a>。</li>
<li><strong>使用类型转换运算符：</strong>略。</li>
</ul>
<h2 id="显式类型转换"><a href="#显式类型转换" class="headerlink" title="显式类型转换"></a>显式类型转换</h2><p>显示类型转换分为 <u>C 语言风格</u>和 <u>C++ 风格</u>两种。</p>
<p><strong>C 语言风格</strong>的显式类型转换语法即是 Java 语言中的显式类型转换语法，为 <code>(目标类型)值</code>。</p>
<p><strong>C++ 风格</strong>的显示类型转换需要使用四种类型转换函数：</p>
<ul>
<li><code>static_cast</code>：静态（编译时）类型转换，并增加编译时的检查，通常用在基本数据类型间等简单的类型转换。</li>
<li><code>reinterpret_cast</code>：使用<a href="#%E7%B1%BB%E5%9E%8B%E5%8F%8C%E5%85%B3%EF%BC%88%E5%8E%9F%E5%A7%8B%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C%EF%BC%89">类型双关</a>的做法实现类型转换。</li>
<li><code>const_cast</code>：移除或添加上变量的 <code>const</code> 限定。</li>
<li><code>dynamic_cast</code>：动态（运行时）类型转换，如果转换失败会返回 <code>NULL</code> 或 <code>nullptr</code>，通常用在有继承关系的父类向子类的类型转换。</li>
</ul>
<blockquote>
<p><strong>备注：</strong></p>
<ol>
<li><code>dynamic_cast</code> 要求被转换的类型是一个多态类型，即拥有虚函数的类型。</li>
<li><code>dynamic_cast</code> 需要 RTTI（Runtime Type Information，运行时类型信息）的支持，它会增加一定的开销。</li>
</ol>
</blockquote>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>变量是用于存储数据的<strong>可访问内存位置</strong>（使用符号或指针访问），且<strong>数据可以改变</strong>。</p>
<p>变量分为<u>定义的变量</u>和<u>在堆上创建的变量</u>。其中，定义的变量又分为<u>全局变量</u>、<u>局部变量</u>和<u>成员变量</u>，取决于在<u>全局作用域中</u>、在<u>局部作用域中</u>，还是在<u>类和结构体中</u>定义。</p>
<blockquote>
<p><strong>备注：</strong></p>
<p>全局作用域指源文件顶层；局部作用域指局部代码块中。</p>
</blockquote>
<h3 id="创建（和初始化）"><a href="#创建（和初始化）" class="headerlink" title="创建（和初始化）"></a>创建（和初始化）</h3><p>变量的创建，本质上是<strong>为变量分配一块内存</strong>，让它能够真正的存储值。</p>
<p>变量是用于存储数据的可访问内存位置，且数据可以改变，因此变量在<u>创建时可以不初始化</u>。但变量在<u>使用前必须初始化</u>，因为变量在创建时只会进行内存分配，内存中依然保存着原来的值（Java 语言会设置为 <code>0</code>）。</p>
<p><u>成员变量</u>的创建由实例决定，<u>非成员变量</u>的<strong>创建方式</strong>分为两种：</p>
<ul>
<li><p><strong>定义变量（在数据段或栈上创建变量）</strong>：使用定义变量的语法，创建的是一个<u>有明确符号的变量</u>。</p>
</li>
<li><p><strong>在堆上创建变量</strong>：使用 <code>new</code> 关键字，运行期间在堆上分配内存（即动态分配内存），并创建一个指针变量用来保存分配的堆内存地址，创建的是一个<u>没有明确符号、用指针访问的变量</u>。</p>
</li>
</ul>
<blockquote>
<p><strong>备注：</strong></p>
<ol>
<li>变量的定义，本质是为一个变量符号分配一块内存，让它能够存储值。</li>
<li>类或结构体类型的变量创建时，可能对它的成员变量进行初始化，取决于构造函数中的代码实现。</li>
<li>用定义变量的语法创建一个类或结构体类型的变量时，会调用它的默认构造函数。当然，也可以显示指定要调用的构造函数。</li>
<li>堆内存需要使用 <code>delete</code> 或 <code>delete[]</code> 关键字手动释放。</li>
</ol>
</blockquote>
<p>一个简单的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义的方式，在数据段上创建变量（和初始化）</span></span><br><span class="line"><span class="type">int</span> var1;</span><br><span class="line"><span class="type">int</span> var2 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在堆上创建变量（和初始化）</span></span><br><span class="line"><span class="type">int</span>* var3 = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="type">int</span>* var4 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Class</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Class</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 对成员变量 value 初始化</span></span><br><span class="line">        value = <span class="number">1</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value is &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 定义的方式，在堆上创建变量（和初始化）</span></span><br><span class="line">    <span class="type">int</span> var3;</span><br><span class="line">    <span class="type">int</span> var4 = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 类或结构体类型的变量创建时，会调用它的构造函数，可能对成员变量进行初始化</span></span><br><span class="line">    Class class1; <span class="comment">// &gt;&gt; Value is 1</span></span><br><span class="line">    Class* class2 = <span class="keyword">new</span> <span class="built_in">Class</span>(); <span class="comment">// &gt;&gt; value is 1</span></span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常见变量创建语法"><a href="#常见变量创建语法" class="headerlink" title="常见变量创建语法"></a>常见变量创建语法</h3><p><strong>定义变量</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本类型</span></span><br><span class="line"><span class="type">int</span> intValue = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针</span></span><br><span class="line"><span class="comment">// 关于指针，需要注意 “* 其实是和 intPointer 放在一起的”</span></span><br><span class="line"><span class="comment">// 例如：int* a, b 得到的其实是指向 int 类型变量的指针 a 和 int 类型的变量 b</span></span><br><span class="line"><span class="comment">// 因此编写代码时，强烈建议将“多个变量的定义分行书写”</span></span><br><span class="line"><span class="type">int</span>* intPointer = &amp;intValue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组，一维数组 intArray、二维数组 intArray2D</span></span><br><span class="line"><span class="type">int</span> intArray[<span class="number">5</span>]&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;; <span class="comment">// 列表初始化（C++ 11）</span></span><br><span class="line"><span class="type">int</span> intArray2D[<span class="number">5</span>][<span class="number">5</span>]&#123;&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;, &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;, &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;, &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;, &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* str1 = <span class="string">&quot;Hello&quot;</span>; <span class="comment">// 原始字符串</span></span><br><span class="line">std::string str2 = <span class="string">&quot;Hello&quot;</span>; <span class="comment">// 其实是一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类和结构体</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> radius;</span><br><span class="line">    <span class="built_in">Circle</span>(<span class="type">double</span> r) : <span class="built_in">radius</span>(r) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Circle <span class="title">circle1</span><span class="params">(<span class="number">5.0</span>)</span></span>; <span class="comment">// 构造函数</span></span><br><span class="line">Circle circle2&#123; <span class="number">5.0</span> &#125;; <span class="comment">// 也是列表初始化（C++ 11）</span></span><br></pre></td></tr></table></figure>

<p><strong>在堆上创建变量</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本类型</span></span><br><span class="line"><span class="type">int</span>* intValue = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="comment">// 数组，一维数组 intArray、二维数组 intArray2D</span></span><br><span class="line"><span class="comment">// 对于数组，要注意动态分配返回的是“指向数组首个元素的指针”</span></span><br><span class="line"><span class="comment">// 因此一维数组使用 int*，二维数组使用 int(*)[n]</span></span><br><span class="line"><span class="type">int</span>* intArray = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>]&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;; <span class="comment">// 列表初始化（C++ 11）</span></span><br><span class="line"><span class="built_in">int</span> (*intArray2D)[<span class="number">5</span>] = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>][<span class="number">5</span>]&#123;&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;, &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;, &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;, &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;, &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* str1 = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">6</span>]&#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125;; <span class="comment">// 列表初始化（C++ 11）</span></span><br><span class="line">std::string* str2 = <span class="keyword">new</span> std::<span class="built_in">string</span>(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// 其实是一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类和结构体</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> radius;</span><br><span class="line">    <span class="built_in">Circle</span>(<span class="type">double</span> r) : <span class="built_in">radius</span>(r) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Circle* circle = <span class="keyword">new</span> <span class="built_in">Circle</span>(<span class="number">5.0</span>); <span class="comment">// 构造函数</span></span><br><span class="line">Circle* circle2 = <span class="keyword">new</span> Circle&#123;<span class="number">5.0</span>&#125;; <span class="comment">// 也是列表初始化（C++ 11）</span></span><br></pre></td></tr></table></figure>

<h3 id="作用域、生命周期和内存位置"><a href="#作用域、生命周期和内存位置" class="headerlink" title="作用域、生命周期和内存位置"></a>作用域、生命周期和内存位置</h3><ul>
<li><p><strong>非静态全局变量</strong>：作用域为整个程序，生命周期为整个程序运行周期，存储在数据段上。</p>
</li>
<li><p><strong>非静态局部变量</strong>：作用域为整个代码块，生命周期随代码块执行结束而结束，存储在栈上。</p>
</li>
<li><p><strong>非静态成员变量：</strong>作用域为实例，生命周期同实例的生命周期，存储位置也取决于实例。</p>
</li>
<li><p><strong>静态全局变量</strong>：作用域为整个翻译单元，生命周期为整个程序运行周期，存储在数据段上。</p>
</li>
<li><p><strong>静态局部变量：</strong>作用域为整个代码块，但生命周期为整个程序运行周期，存储在数据段上。</p>
</li>
<li><p><strong>静态成员变量：</strong>作用域为类或结构体，生命周期为整个程序运行周期，存储在数据段上。</p>
</li>
<li><p><strong>在堆上创建的变量</strong>：没有固定的作用域，生命周期由我们控制，存储在堆上。</p>
</li>
</ul>
<p>以三个概念分别总结：</p>
<p><strong>作用域</strong>：</p>
<ul>
<li>程序：非静态全局变量</li>
<li>翻译单元：静态全局变量</li>
<li>代码块：局部变量</li>
<li>实例：非静态成员变量</li>
<li>类或结构体：静态成员变量</li>
<li>不固定：在堆上创建的变量</li>
</ul>
<p><strong>生命周期：</strong></p>
<ul>
<li>程序：全局变量、静态变量</li>
<li>代码块：非静态局部变量</li>
<li>实例：非静态局部变量</li>
<li>不固定：在堆上创建的变量</li>
</ul>
<p><strong>内存位置：</strong></p>
<ul>
<li>数据段：全局变量、静态变量</li>
<li>取决于实例：成员变量</li>
<li>栈：非静态局部变量</li>
<li>堆：在堆上创建的变量</li>
</ul>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>常量是存储着<strong>不可修改数据</strong>的可访问内存。</p>
<p>常量分为<u>常量变量</u>和<u>常量表达式</u>，取决于使用 <code>const</code> 关键字修饰，还是使用 <code>constexpr</code> 关键字修饰。</p>
<h3 id="创建和初始化"><a href="#创建和初始化" class="headerlink" title="创建和初始化"></a>创建和初始化</h3><p>常量是存储着不可修改数据的可访问内存，因此常量在<u>创建时必须初始化</u>。</p>
<p>常量的<strong>创建方式</strong>分两种：</p>
<ul>
<li><p><strong>创建常量变量：</strong>值在<u>运行时</u>确定（例如从函数的返回值中获得），并在初始化后不可更改。</p>
</li>
<li><p><strong>创建常量表达式：</strong>值必须在<u>编译时</u>确定，且使用它的地方会被编译器直接替换为字面量，能够提升编译期优化的效果，通常配合 <code>constexpr</code> 函数使用。</p>
</li>
</ul>
<p>一个简单的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> sum1 = <span class="built_in">add1</span>(<span class="number">5</span>, <span class="number">10</span>); <span class="comment">// 创建常量变量，sum1 赋值为 15 后，不允许修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通常配合 constexpr 函数使用</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="title">add2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> sum2 = <span class="built_in">add2</span>(<span class="number">5</span>, <span class="number">10</span>); <span class="comment">// 创建常量表达式，编译时求值优化为 constexpr int sum2 = 15</span></span><br></pre></td></tr></table></figure>

<h3 id="常见常量创建语法"><a href="#常见常量创建语法" class="headerlink" title="常见常量创建语法"></a>常见常量创建语法</h3><p><strong>创建常量变量：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> variableInt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本类型、数组、结构体</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> CONST_INT = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针</span></span><br><span class="line"><span class="comment">// const 在 * 前表示指针指向常量；const 在 * 后表示这是常量指针。eg：</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* pointerToConstInt = &amp;CONST_INT; <span class="comment">// 一个指向 int 常量的指针</span></span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> CONST_POINTER_TO_INT = &amp;variableInt; <span class="comment">// 一个指向 int 变量的常量指针</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> CONST_POINTER_TO_CONST_INT = &amp;CONST_INT; <span class="comment">// 一个指向 int 常量的常量指针</span></span><br></pre></td></tr></table></figure>

<p><strong>创建常量表达式：</strong>略。</p>
<h3 id="作用域、生命周期和内存位置-1"><a href="#作用域、生命周期和内存位置-1" class="headerlink" title="作用域、生命周期和内存位置"></a>作用域、生命周期和内存位置</h3><ul>
<li><p><strong>常量变量：</strong>与变量一致。</p>
</li>
<li><p><strong>常量表达式</strong>：不存在作用域、生命周期和内存位置的概念，因为它在编译时期就被替换成了<u>字面量</u>。</p>
</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>函数本质上是<strong>一组代码语句的集合</strong>，或者说 CPU 指令的集合。</p>
<p>函数分为<u>函数</u>和<u>成员函数</u>（即方法），取决于定义在<u>全局作用域</u>还是定义<u>在类和结构体中</u>。</p>
<blockquote>
<p><strong>备注：</strong></p>
<p>相较于变量来说，函数没有局部的概念。除成员函数外，函数都是全局的。</p>
</blockquote>
<h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>函数的声明，本质上是告诉编译器这个<strong>函数的签名</strong>，同时告诉编译器函数的定义存在于某个翻译单元中，将来由链接器完成定义的链接，现在请<strong>允许我使用这个函数</strong>。</p>
<p>一个函数可以被声明多次。</p>
<p>一个简单的例子：</p>
<p><em>Main.cpp</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明函数 globalPrint 存在于某个翻译单元，请允许使用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">globalPrint</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 声明函数 localPrint 存在于某个翻译单元，请允许使用</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">localPrint</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">globalPrint</span>(<span class="string">&quot;Global&quot;</span>); <span class="comment">// &gt;&gt; Global</span></span><br><span class="line">    <span class="built_in">localPrint</span>(<span class="string">&quot;Local&quot;</span>); <span class="comment">// &gt;&gt; Local</span></span><br><span class="line">    </span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>Extern.cpp</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">globalPrint</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">localPrint</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>函数的定义，本质是为一个<strong>函数符号</strong>提供函数的具体实现，即<strong>函数体</strong>。</p>
<p>一个简单的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数的声明</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数的定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// &gt;&gt; Hello</span></span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>C++ 中函数的参数传递犹如是<strong>创建一个形参变量，并使用实参变量对它初始化</strong>，例如 <code>int parameter = argument</code>。</p>
<p>由于参数传递的这个特点，使用引用作为形参时，其实只是对实参变量起了一个别名，因此不会创建实参变量的副本。此时，我们使用引用就是在使用实参变量本身。</p>
<p>所以，使用<strong>除引用外的类型</strong>作为形参时，函数都在使用<strong>值传递</strong>方式；使用<strong>引用类型</strong>作为形参时，函数在使用<strong>引用传递</strong>方式。</p>
<p>一个简单的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 犹如为变量 a 起了别名 int&amp; target = a，以及创建了变量 b 的副本 int source = b</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addTo</span><span class="params">(<span class="type">int</span>&amp; target, <span class="type">int</span> source)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    source++;</span><br><span class="line">    target += source;</span><br><span class="line">    std::cout &lt;&lt; target &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">addTo</span>(a, b); <span class="comment">// &gt;&gt; 16</span></span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; std::endl; <span class="comment">// 使用引用，所以 a 变了 &gt;&gt; 16</span></span><br><span class="line">    std::cout &lt;&lt; b &lt;&lt; std::endl; <span class="comment">// 创建副本，所以 b 没变 &gt;&gt; 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><p>在函数声明前使用<code>inline</code>关键字修饰，可以<strong>建议</strong>编译器将该函数的调用代码内联，即<strong>用函数体替换函数调用</strong>，以避免函数调用带来的开销。</p>
<p>内联适合短小的、频繁调用的函数。</p>
<blockquote>
<p><strong>备注：</strong></p>
<p>说是建议，是因为编译器可能不会内联较复杂的函数。</p>
</blockquote>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p>指针是一个<strong>特殊的变量</strong>，存储着整型数据，它的值表示<strong>内存中某个字节的地址</strong>。</p>
<p>指针的类型其实是用来告诉编译器，它指向的地址所属变量的类型。</p>
<p>有关指针的常用运算符：</p>
<ul>
<li><strong>&amp; 取地址运算符：</strong>实质上是在获取一个变量或函数的指针（获取指针）</li>
<li>*** 解引用运算符：**实质上是在获取指针指向变量的值（获取值）</li>
<li><strong>-&gt; 箭头运算符：</strong>实质上是对指针操作的语法糖，<code>ptr-&gt;value</code> 等价于 <code>(*ptr).value</code></li>
</ul>
<h3 id="创建和初始化-1"><a href="#创建和初始化-1" class="headerlink" title="创建和初始化"></a>创建和初始化</h3><p>指针变量<strong>本身</strong>只能通过<strong>定义的方式</strong>创建，遵循定义变量的语法。</p>
<p>数组指针的类型比较复杂，其格式是：<code>元素类型 (*数组指针名称)[元素个数]</code>。</p>
<p>函数指针的类型比较复杂，其格式是：<code>返回值类型 (*函数指针名称)(参数列表)</code>。</p>
<p>指针有两种主要的初始化方式：对变量或函数<strong>做取地址运算</strong>和<strong>使用动态分配的地址</strong>。</p>
<blockquote>
<p><strong>备注：</strong></p>
<p>使用 <code>typedef</code> 或 <code>using</code> 为原始函数指针的类型起别名时要注意，别名的位置同变量名称的位置，即：<code>typedef 返回值类型(*新类型名称)(参数列表)</code></p>
</blockquote>
<p>一个简单的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 起类型别名</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*AddFunction)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span>(*function1)(<span class="type">int</span>, <span class="type">int</span>) = add; <span class="comment">// function1 函数指针</span></span><br><span class="line">    AddFunction function2 = add; <span class="comment">// function2 函数指针</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span>* ptr1 = &amp;a; <span class="comment">// 对变量做取地址运算</span></span><br><span class="line">    <span class="type">int</span>* ptr2 = <span class="keyword">new</span> <span class="type">int</span>; <span class="comment">// 使用动态分配的地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p>智能指针指的是 C++ 标准库中提供的 <code>unique_ptr</code>、<code>shared_ptr</code> 和 <code>weak_ptr</code>。</p>
<ul>
<li><p><code>unique_ptr</code> 是<strong>独占变量所有权</strong>的指针，适合用于局部作用域内的资源管理，自动释放，不能复制。它的实现利用了堆上创建的变量离开作用域时自动销毁，以及对象销毁时会执行析构函数的特点，在离开作用域时，<code>unique_ptr</code> 就会执行在析构函数中设置好的 <code>delete</code> 操作。<code>unique_ptr</code> 的实现逻辑很简单，使用开销很小，但它不能共享，共享可能导致野指针问题。正因如此，它的拷贝构造函数和赋值操作符都被设置为了 <code>delete</code>。</p>
</li>
<li><p><code>shared_ptr</code> 是<strong>支持共享变量所有权</strong>的指针，内部维护一个引用计数。每当有<code>shared_ptr</code>指向同一个对象时，引用计数增加；当指针失效时，引用计数减少到 0，自动调用<code>delete</code>释放资源。<code>shared_ptr</code> 的实现和设计复杂，因此，它的使用开销也比较大。</p>
</li>
<li><p><code>weak_ptr</code> 一般配合<code>shared_ptr</code>使用，它不会让引用计数增加。</p>
</li>
</ul>
<p><strong>我们应该遵守一个原则：使用智能指针时，优先选择开销小的 <code>unique_ptr</code>，除非需要共享所有权。</strong></p>
<p>一个简单的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Entity created&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">Entity</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Entity destroyed&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 使用 unique_ptr</span></span><br><span class="line">        std::unique_ptr&lt;Entity&gt; uniquePtr = std::<span class="built_in">make_unique</span>&lt;Entity&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 shared_ptr</span></span><br><span class="line">        std::shared_ptr&lt;Entity&gt; sharedPtr1 = std::<span class="built_in">make_shared</span>&lt;Entity&gt;();</span><br><span class="line">        &#123;</span><br><span class="line">            std::shared_ptr&lt;Entity&gt; sharedPtr2 = sharedPtr1; <span class="comment">// 共享变量所有权，引用计数加 1</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;sharedPtr1 count: &quot;</span></span><br><span class="line">                &lt;&lt; sharedPtr1.<span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// &gt;&gt; 2</span></span><br><span class="line"></span><br><span class="line">            std::weak_ptr&lt;Entity&gt; weakPtr = sharedPtr1; <span class="comment">// 共享变量所有权，但引用计数不变</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// sharedPtr2、weakPtr 离开作用域，引用计数只减 1</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;sharedPtr1 count: &quot;</span> &lt;&lt; sharedPtr1.<span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// &gt;&gt; 1</span></span><br><span class="line">    &#125; <span class="comment">// 离开作用域，所有智能指针释放内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><p>函数本质上是一组 CPU 指令的集合，它也被存储在内存中，拥有自己的地址，我们可以认为<strong>函数名称也是一种变相的指针</strong>。因此，函数也可以使用指针来指向，即<strong>函数指针</strong>。</p>
<p>C++ 的函数指针保留了 C 语言的写法，因此函数指针也称为<strong>原始函数指针</strong>。</p>
<p>函数指针是一种传递函数的方法，它可以实现<u>回调函数</u>，也使得结构体中可以间接拥有函数。</p>
<p>函数在赋值给指针时，会隐式使用取地址操作符进行类型转换。</p>
<p>函数指针的使用方式与函数调用一致。</p>
<blockquote>
<p><strong>备注：</strong></p>
<p>在 C++ 中，原始数组、原始字符串等于“原始”有关的概念大多来自于 C 语言。</p>
</blockquote>
<p>一个简单的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">int</span>(*function)(<span class="type">int</span>, <span class="type">int</span>) = add; <span class="comment">// 将函数 add 的地址赋值给原始函数指针 function</span></span><br><span class="line">     </span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">function</span>(<span class="number">1</span>, <span class="number">5</span>) &lt;&lt; std::endl; <span class="comment">// 像函数一样使用 &gt;&gt; 6</span></span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><h3 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h3><p>引用<strong>不是一个变量</strong>，是为一个变量起的别名，对某类型变量的引用等价于这个变量自身。</p>
<blockquote>
<p><strong>备注：</strong></p>
<ol>
<li>指针是变量，因此指向一种数据类型的指针属于另一种独立的数据类型。</li>
<li>引用不是变量，因此对一种数据类型的引用就等同这种数据类型，可以相互替换，区别在于值传递方式。</li>
</ol>
</blockquote>
<h3 id="创建和初始化-2"><a href="#创建和初始化-2" class="headerlink" title="创建和初始化"></a>创建和初始化</h3><p>引用只能使用同类型的变量做初始化，我们可以将引用的创建和初始化理解为<strong>为变量起了一个别名</strong>。因此，引用在<u>创建时必须初始化</u>。</p>
<p>一个简单的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span>&amp; ref1 = a; <span class="comment">// 为变量 a 起了一个别名 ref1</span></span><br><span class="line">    </span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="引用和指针"><a href="#引用和指针" class="headerlink" title="引用和指针"></a>引用和指针</h3><p>在功能上，可以说引用是对指针的功能封装，一个变量的引用在使用上等价于指向这个变量的指针解引用运算的结果。</p>
<p>引用和指针的区别在于：</p>
<ul>
<li>引用<strong>必须引用已有变量</strong>；指针<strong>可以指向未知地址</strong>，即指针的值可以不初始化或初始化为 <code>0</code>、<code>NULL</code>、<code>nullptr</code> 等不存在的内存地址。</li>
<li>引用可以确保指向有效数据，相比指针更安全；指针若初始化不当，容易产生悬空指针等问题。</li>
<li>引用引用一个变量，相当于告诉编译器这两个标识符都代表内存中的同一块区域，不会分配新的内存空间，因此<strong>不额外占用内存</strong>；指针指向一个变量，需要分配新的内存空间，并将值设置成另一个变量的地址，会<strong>额外占用内存</strong></li>
<li>引用<strong>一旦绑定就无法更改</strong>；指针<strong>可以重新赋值</strong>指向其他变量</li>
<li>引用更适用于<strong>数据传递</strong>，写出来的代码安全性和可读性更强；指针更适用于<strong>动态内存管理</strong>。</li>
</ul>
<p>一图分清：</p>
<p>![指针与引用](images&#x2F;CPP RUSH PLAN.drawio.png)</p>
<p>一个简单的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>&amp; refToA = a;</span><br><span class="line">    <span class="type">int</span>* ptrToA = &amp;a;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// refToA 使用上等价于 *ptrToA</span></span><br><span class="line">    std::cout &lt;&lt; refToA &lt;&lt; std::endl; <span class="comment">// &gt;&gt; 1</span></span><br><span class="line">    std::cout &lt;&lt; *ptrToA &lt;&lt; std::endl; <span class="comment">// &gt;&gt; 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="引用和函数"><a href="#引用和函数" class="headerlink" title="引用和函数"></a>引用和函数</h3><p>由于引用不是变量，因此<strong>对一种数据类型的引用</strong>就等同<strong>这种数据类型</strong>，可以<strong>相互替换</strong>。将它们替换使用，使得在函数的形参和返回值可以实现值传递方式和引用传递方式，详见<a href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92">前文</a>。</p>
<p>需要注意的是，<strong>不要返回局部变量的引用</strong>。因为局部变量在函数返回后立即销毁，返回其引用会产生悬空引用，导致未定义行为。返回对象成员的引用也要确保引用的成员不会在对象销毁前被销毁。</p>
<p>一个简单的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* m_Buffer;</span><br><span class="line">    <span class="type">int</span> m_Size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* string)</span><br><span class="line">    &#123;</span><br><span class="line">        m_Size = <span class="built_in">strlen</span>(string);</span><br><span class="line">        m_Buffer = <span class="keyword">new</span> <span class="type">char</span>[m_Size + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memcpy</span>(m_Buffer, string, m_Size);</span><br><span class="line">        m_Buffer[m_Size] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">String</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_Buffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 希望使用引用传递返回值，且可以确保返回的引用不会在对象销毁前销毁</span></span><br><span class="line">    <span class="comment">// 因此使用 char&amp; 替代 char</span></span><br><span class="line">    <span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">unsigned</span> <span class="type">int</span> index)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_Buffer[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    String string = <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用引用，犹如为 string.m_Buffer[1] 起了个别名 string[1]：</span></span><br><span class="line">    <span class="comment">// char&amp; string[1] = string.m_Buffer[1]</span></span><br><span class="line">    string[<span class="number">1</span>] = <span class="string">&#x27;a&#x27;</span>; </span><br><span class="line">    </span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="枚举和枚举类"><a href="#枚举和枚举类" class="headerlink" title="枚举和枚举类"></a>枚举和枚举类</h2><p>枚举 <code>enum</code>和枚举类 <code>enum class</code> 的作用是为难以理解含义的常量整数值，<strong>赋予具体的名称和意义</strong>。</p>
<p>枚举和枚举类的值默认使用 <code>int</code> 类型，也可以使用<strong>继承的语法</strong>来设置他们为其他<strong>任意的整数类型</strong>。</p>
<p>在未对枚举和枚举类的值赋值时，第一个值默认为 <code>0</code>，其他的值默认为前一个值增加 <code>1</code>。</p>
<p>为了兼容 C，C++ 中的枚举保留了 C 的写法，使用枚举类来提供对枚举的改进，<del>因此我们可以说枚举是原始枚举（雾）</del>。</p>
<p>枚举和枚举类的区别在于：</p>
<ul>
<li><p><strong>作用域</strong>：枚举的值，其作用域为<u>枚举所在的整个作用域</u>；枚举类的值，其作用域为<u>枚举类自身</u>。</p>
</li>
<li><p><strong>类型安全</strong>：枚举的值<u>能隐式转换</u>为整数类型；枚举类的值<u>不能隐式转换</u>为整数类型</p>
</li>
</ul>
<p><strong>我们应该遵守一个原则：尽可能使用枚举类，因为它的作用域更合理，安全性更好。</strong></p>
<p>一个简单的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">EnumInt</span></span><br><span class="line">&#123;</span><br><span class="line">    A, B, C <span class="comment">// A，B，C 的值分别是 0，1，2，作用域为全局</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">EnumUChar</span> : <span class="type">unsigned</span> <span class="type">char</span> <span class="comment">// 使用继承的语法，设置值的类型为 unsigned char</span></span><br><span class="line">    &#123;</span><br><span class="line">        A = <span class="number">1</span>, B = <span class="number">5</span>, C <span class="comment">// A，B，C 的值分别是 1，5，6，作用域为 Struct</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">EnumClassInt</span></span><br><span class="line">&#123;</span><br><span class="line">    A = <span class="number">1</span>, B, C <span class="comment">// A, B, C 的值分别为 1, 2, 3，作用域被限制在 EnumClassInt 中</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 枚举的值，其作用域在枚举所在的整个作用域，因此 EnumInt 中值 B 的作用域为全局</span></span><br><span class="line">    EnumInt value1 = B;</span><br><span class="line">    <span class="keyword">if</span> (value1 == B)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;value1 is B!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 枚举的值，其作用域在枚举所在的整个作用域，因此 EnumUChar 中值 B 的作用域为 Struct</span></span><br><span class="line">    Struct::EnumUChar value2 = Struct::B;</span><br><span class="line">    <span class="keyword">if</span> (value2 == Struct::B)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;value2 is Struct::B!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 枚举类的值，其作用域为枚举类自身，因此 EnumClassInt 中值 B 的作用域为 EnumClassInt</span></span><br><span class="line">    EnumClassInt value3 = EnumClassInt::B;</span><br><span class="line">    <span class="keyword">if</span> (value3 == EnumClassInt::B)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;value3 is EnumClassInt::B!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> anInt1 = EnumInt::B; <span class="comment">// 能隐式转换</span></span><br><span class="line">    <span class="comment">// int anInt2 = EnumClassInt::B; // 不能隐式转换</span></span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类和结构体"><a href="#类和结构体" class="headerlink" title="类和结构体"></a>类和结构体</h2><h3 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h3><p>类是一个组织数据和操作数据的函数的方式，是一种自定义的数据类型。</p>
<p>C++ 中的结构体保留了 C 的写法，这也导致了除成员可见性外，C++ 中的<u>类和结构体完全等价</u>。具体区别在于：</p>
<ul>
<li>为了符合面向对象编程的原则，类中的成员默认是 <code>private</code> 的；为了兼容 C 语言，结构体的成员默认是 <code>public</code> 的。</li>
<li>人们在更倾向于使用结构体表达只包含数据的事物（如顶点），使用类表示包含操作的事物（如播放器）。</li>
</ul>
<blockquote>
<p><strong>备注：</strong></p>
<p>为符合面向对象的规范，在后文只使用类和实例（对象）这两个概念，但实质上，类和结构体在功能上是等价的。</p>
</blockquote>
<p>一个简单的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span> <span class="comment">// struct Log 与之完全等价</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// public 成员变量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> LogLevelError = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> LogLevelWarning = <span class="number">1</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> LogLevelInfo = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// private 成员变量</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_LogLevel = LogLevelInfo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// public 成员函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setLevel</span><span class="params">(<span class="type">int</span> level)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_LogLevel = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">error</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_LogLevel &gt;= LogLevelError)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[ERROR]:&quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">warn</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_LogLevel &gt;= LogLevelWarning)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[WARNING]:&quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">info</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_LogLevel &gt;= LogLevelInfo)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[INFO]:&quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 实例化</span></span><br><span class="line">    Log log;</span><br><span class="line">    log.<span class="built_in">setLevel</span>(log.LogLevelWarning);</span><br><span class="line">    log.<span class="built_in">error</span>(<span class="string">&quot;FBI OPEN THE DOOR!&quot;</span>);</span><br><span class="line">    log.<span class="built_in">warn</span>(<span class="string">&quot;FBI OPEN THE DOOR!&quot;</span>);</span><br><span class="line">    log.<span class="built_in">info</span>(<span class="string">&quot;FBI OPEN THE DOOR!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="声明-1"><a href="#声明-1" class="headerlink" title="声明"></a>声明</h3><p>类的声明本质上是告诉编译器，我<u>创建了一个新的类型</u>，可以用作变量创建、函数参数和返回值等操作。</p>
<p>类可以在<u>全局作用域</u>、<u>局部作用域</u>、<u>类和结构体</u>中声明。</p>
<p>需要注意，编译器<strong>不允许对成员变量进行多次声明</strong>，并认为这是<strong>重定义错误</strong>，因为类在实例化时会跟据成员变量的声明完成他们的创建。</p>
<p>一个简单的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Class</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 同时向编译器声明了它的成员变量 value、count</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="comment">// int count; // 不允许再次声明，提示重定义错误</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Class::count;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用作变量创建</span></span><br><span class="line">Class aClass;</span><br></pre></td></tr></table></figure>

<h3 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h3><p>对象的创建称为实例化，本质上是<strong>类类型变量的创建</strong>。</p>
<p>类实例化时，会在构造函数执行前完成<u>非静态成员变量</u>的创建，随后构造函数才被调用，以便我们为成员变量赋值。因此要格外注意，<u>静态成员变量</u>需要在类外单独完成创建才能使用。</p>
<p>常见的实例化方式有<u>调用构造函数</u>、<u>列表初始化</u>（C++ 11），当然也区分<u>定义变量</u>和<u>在堆上创建变量</u>两种方式。<a href="#%E5%88%9B%E5%BB%BA%EF%BC%88%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%89">前文</a>已有，在此不做赘述。</p>
<p>一个简单的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>()</span><br><span class="line">        : <span class="built_in">name</span>(<span class="string">&quot;Unknown&quot;</span>), <span class="built_in">age</span>(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">int</span> age)</span><br><span class="line">        : <span class="built_in">name</span>(name), <span class="built_in">age</span>(age)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 在类先完成创建</span></span><br><span class="line"><span class="type">int</span> Person::count;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认构造函数实例化对象</span></span><br><span class="line">    Person person1; <span class="comment">// 或 Person person1 = Person()</span></span><br><span class="line">    person1.<span class="built_in">printName</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有参构造函数实例化对象</span></span><br><span class="line">    <span class="function">Person <span class="title">person2</span><span class="params">(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>)</span></span>; <span class="comment">// 或 Person person2 = Person(&quot;Alice&quot;, 30)</span></span><br><span class="line">    person2.<span class="built_in">printName</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认构造函数列表初始化（C++ 11）</span></span><br><span class="line">    Person person3&#123;&#125;; <span class="comment">// 或 Person person3 = &#123;&#125;，或 Person person3Too = Person&#123;&#125;;</span></span><br><span class="line">    person3.<span class="built_in">printName</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有参构造函数列表初始化（C++ 11）</span></span><br><span class="line">    Person person4&#123; <span class="string">&quot;Bob&quot;</span>, <span class="number">25</span> &#125;; <span class="comment">// 或 Person person4 = &#123; &quot;Bob&quot;, 25 &#125;，或 Person person4 = Person&#123; &quot;Bob&quot;, 25 &#125;</span></span><br><span class="line">    person4.<span class="built_in">printName</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用栈内存省略</span></span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数在<strong>实例化时</strong>、<strong>成员变量创建后</strong>调用，我们会在构造函数中对对象做初始化操作。</p>
<p>和 Java 一样，构造函数是一个没有返回值、和类同名的函数，如果类中<u>没有提供任何构造函数</u>，编译器会为其添加一个空的默认构造函数。</p>
<p>在调用默认构造函数时，定义变量的方式<strong>不能带有</strong>方法圆括号，在堆上创建变量的方式<strong>可以带有也可以不带有</strong>。</p>
<p>一个简单的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">float</span> m_X, m_Y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">Entity</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_X = <span class="number">0.0f</span>;</span><br><span class="line">        m_Y = <span class="number">0.0f</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有参构造函数</span></span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">float</span> x, <span class="type">float</span> y)</span><br><span class="line">    &#123;</span><br><span class="line">        m_X = x;</span><br><span class="line">        m_Y = y;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; m_X &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; m_Y &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 调用默认构造函数</span></span><br><span class="line">    Entity e1; <span class="comment">// 不可以带有小括号“()”</span></span><br><span class="line">    e1.<span class="built_in">print</span>(); <span class="comment">// &gt;&gt; 0, 0</span></span><br><span class="line">    Entity* e2 = <span class="keyword">new</span> <span class="built_in">Entity</span>(); <span class="comment">// 可以带有也可以不带有小括号“()”</span></span><br><span class="line">    e2-&gt;<span class="built_in">print</span>(); <span class="comment">// &gt;&gt; 0, 0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用有参构造函数</span></span><br><span class="line">    <span class="function">Entity <span class="title">e3</span><span class="params">(<span class="number">5.0f</span>, <span class="number">5.0f</span>)</span></span>;</span><br><span class="line">    e3.<span class="built_in">print</span>(); <span class="comment">// &gt;&gt; 5, 5</span></span><br><span class="line">    Entity* e4 = <span class="keyword">new</span> <span class="built_in">Entity</span>(<span class="number">5.0f</span>, <span class="number">5.0f</span>);</span><br><span class="line">    e4-&gt;<span class="built_in">print</span>(); <span class="comment">// &gt;&gt; 5, 5</span></span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><p>在构造函数中，如果只是简单的为成员变量赋值，可以使用初始化列表。</p>
<p><strong>非静态常量成员和引用类型成员</strong>必须使用初始化列表进行初始化。</p>
<p>类实例化时，在<u>构造函数执行前</u>就会完成成员变量的创建，以便我们为成员变量赋值。然而对于类类型的成员变量来说，他们在创建时会<u>执行默认构造方法</u>，创建一个空实例，如果我们在构造方法中再次创建一个新的实例并赋值给该成员变量，就会造成<strong>二次实例化</strong>，拖慢性能。使用初始化列表可以控制<strong>成员变量创建时</strong>所接受的值&#x2F;所调用的构造函数，避免二次实例化。</p>
<p>要注意的是，初始化列表的初始化顺序并不是按声明顺序写的，而是按<strong>成员在类中声明的顺序</strong>，当成员变量之间存在依赖关系时，要注意初始化的先后顺序。</p>
<p>一个简单的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wheel</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">float</span> m_Length;</span><br><span class="line">    <span class="type">float</span> m_Width;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Wheel</span>()</span><br><span class="line">        : <span class="built_in">m_Length</span>(<span class="number">0.0f</span>), <span class="built_in">m_Width</span>(<span class="number">0.0f</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Wheel created default!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Wheel</span>(<span class="type">float</span> length, <span class="type">float</span> width)</span><br><span class="line">        : <span class="built_in">m_Length</span>(length), <span class="built_in">m_Width</span>(width)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Wheel created!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; m_Length &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; m_Width &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用初始化列表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Wheel m_Wheel;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Car1</span>()</span><br><span class="line">        : <span class="built_in">m_Wheel</span>(<span class="number">10.0f</span>, <span class="number">5.0f</span>) <span class="comment">// 使用初始化列表</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_Wheel.<span class="built_in">print</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不使用初始化列表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Wheel m_Wheel;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Car2</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_Wheel = <span class="built_in">Wheel</span>(<span class="number">10.0f</span>, <span class="number">5.0f</span>); <span class="comment">// 不使用初始化列表，在构造函数中赋值</span></span><br><span class="line">        m_Wheel.<span class="built_in">print</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">int</span> a, <span class="type">int</span> b) : <span class="built_in">y</span>(b), <span class="built_in">x</span>(y + a) &#123;&#125; <span class="comment">// 这里 x 将先于 y 初始化，可能导致未定义行为</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Car1 car1;</span><br><span class="line">    <span class="comment">// 避免了二次实例化</span></span><br><span class="line">    <span class="comment">// &gt;&gt; Wheel created!</span></span><br><span class="line">    <span class="comment">// &gt;&gt; 10 * 5</span></span><br><span class="line">    Car2 car2;</span><br><span class="line">    <span class="comment">// 二次实例化！</span></span><br><span class="line">    <span class="comment">// &gt;&gt; Wheel created default!</span></span><br><span class="line">    <span class="comment">// &gt;&gt; Wheel created!</span></span><br><span class="line">    <span class="comment">// &gt;&gt; 10 * 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>析构函数与构造函数相反，在实例销毁时调用。我们会在析构函数中释放实例中的资源，如删除指针等等。</p>
<p>析构函数是一个没有返回值、名为 <code>~类名</code> 的函数。</p>
<p>不同于 Java，C++ 中没有垃圾收集器，因此创建出的堆内存资源在使用完成后需要手动释放。</p>
<p>析构函数也能依据其调用的时间特点，完成一些特殊的功能，如计时器等。</p>
<p>一个简单的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* m_Name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">const</span> <span class="type">char</span>* name)</span><br><span class="line">        : <span class="built_in">m_Name</span>(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Entity</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Entity &quot;</span> &lt;&lt; m_Name &lt;&lt; <span class="string">&quot; destroyed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createEntity</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Entity <span class="title">e1</span><span class="params">(<span class="string">&quot;e1&quot;</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">createEntity</span>(); <span class="comment">// &gt;&gt; Entity e1 destroyed! （函数结束后）</span></span><br><span class="line"></span><br><span class="line">    Entity* e2 = <span class="keyword">new</span> <span class="built_in">Entity</span>(<span class="string">&quot;e2&quot;</span>);</span><br><span class="line">    <span class="keyword">delete</span> e2; <span class="comment">// &gt;&gt; Entity e2 destroyed! </span></span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><p>拷贝构造函数是一个<strong>参数为类本身</strong>的特殊构造函数，它在同一个类类型的对象间赋值时被调用，这也是一种<strong>隐式构造函数转换</strong>。</p>
<p>C++ 会为类提供一个默认的浅拷贝构造函数，因此默认情况下，同一个类类型的对象间赋值时总是会使用拷贝构造函数。</p>
<p><strong>在设计一个接收对象作为参数函数时，有一个不得不提的原则，就是总是使用常量引用来传递对象。</strong>大多数情况下，使用引用传递对象的性能比复制对象的性能要好很多。即使你需要创建对象的拷贝，也应该在函数中手动创建。</p>
<p>一个简单的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* m_Buffer;</span><br><span class="line">    <span class="type">int</span> m_Size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* string)</span><br><span class="line">    &#123;</span><br><span class="line">        m_Size = <span class="built_in">strlen</span>(string);</span><br><span class="line">        m_Buffer = <span class="keyword">new</span> <span class="type">char</span>[m_Size + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memcpy</span>(m_Buffer, string, m_Size);</span><br><span class="line">        m_Buffer[m_Size] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现拷贝构造函数（深拷贝）</span></span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> String&amp; other)</span><br><span class="line">        :<span class="built_in">m_Size</span>(other.m_Size)</span><br><span class="line">    &#123;</span><br><span class="line">        m_Buffer = <span class="keyword">new</span> <span class="type">char</span>[m_Size + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memcpy</span>(m_Buffer, other.m_Buffer, m_Size + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">String</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_Buffer; <span class="comment">// 浅拷贝将导致二次释放内存错误</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">unsigned</span> <span class="type">int</span> index)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_Buffer[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; stream, <span class="type">const</span> String&amp; string);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; stream, <span class="type">const</span> String&amp; string)</span><br><span class="line">&#123;</span><br><span class="line">    stream &lt;&lt; string.m_Buffer;</span><br><span class="line">    <span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printString</span><span class="params">(<span class="type">const</span> String&amp; string)</span> <span class="comment">// 总是使用常量引用来传递对象</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 即使是要创建拷贝，也应该在函数中手动创建</span></span><br><span class="line">    <span class="comment">// Stirn copy = string;</span></span><br><span class="line">    std::cout &lt;&lt; string &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    String string = <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line">    String second = string; <span class="comment">// 使用拷贝构造函数，也是一种隐式转换</span></span><br><span class="line"></span><br><span class="line">    second[<span class="number">1</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; string &lt;&lt; std::endl; <span class="comment">// &gt;&gt; Hello!（浅拷贝将导致 string 也变为 Hallo!）</span></span><br><span class="line">    std::cout &lt;&lt; second &lt;&lt; std::endl; <span class="comment">// &gt;&gt; Hallo!</span></span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">    <span class="comment">// 程序结束，销毁两个对象时，浅拷贝将导致二次释放内存错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>多态指的是<strong>一个类可以拥有多种类型</strong>，通过<u>继承来实现</u>，使用<u>虚函数来保证</u>。</p>
<p>在 C++ 中，当一个类继承自另一个类时，创建子类对象时会在子类对象的一部分内存中创建一个<strong>父类对象</strong>。这部分内存存储了父类的所有成员变量和虚表指针。</p>
<p>由于访问控制的限制，即便父类对象存在于子类对象中，子类也无法<strong>直接访问</strong>父类对象中的 <code>private</code> 成员。</p>
<p>继承时，我们可以使用可见性修饰符来限定继承过来的成员的<strong>最高可见性</strong>。</p>
<p>有关<strong>对象切割</strong>问题：</p>
<ul>
<li><p><strong>定义变量：</strong>定义父类类型变量时，将子类对象赋值给父类类型的变量将产生对象切割问题。因为编译器会<u>依据变量类型确定使用的数据段或栈内存大小</u>，运行时，创建的子类对象才被放入定好大小的内存，导致所有属于子类的成员变量和函数（包括重写的函数）被丢弃。因此，最终内存中存储的其实是<u>一个变相的父类对象</u>。</p>
</li>
<li><p><strong>在堆上创建变量：</strong>不会产生对象切割问题。使用 <code>new</code> 关键字，将在运行时调用子类的构造函数创建子类对象，随后才<u>为整个对象分配堆内存</u>，随后将内存地址赋值给指针。因此，最终内存中存储的就是<u>子类类型的实例</u>。</p>
</li>
</ul>
<blockquote>
<p><strong>备注：</strong></p>
<ol>
<li>C++ 支持多重继承，Java 只支持单继承。</li>
<li>和 Java 类似，C++ 子类的构造函数开始时，隐式调用了父类的构造函数；析构函数结束时，也隐式调用了父类的析构函数。</li>
<li>当子类父类出现同名成员时，可以通过作用域解析运算符指定访问子类还是父类的成员。</li>
</ol>
</blockquote>
<p>一个简单的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_Value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Base</span>()</span><br><span class="line">        : <span class="built_in">m_Value</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> value)</span><br><span class="line">        : <span class="built_in">m_Value</span>(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">basePrint</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[Base]: Value is &quot;</span> &lt;&lt; <span class="built_in">getValue</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同名函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">who</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AnotherBase</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">where</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Here&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base, <span class="keyword">public</span> AnotherBase <span class="comment">// 多重继承</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_Key;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>()</span><br><span class="line">        : <span class="built_in">m_Key</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Derived</span>(<span class="type">int</span> key)</span><br><span class="line">        : <span class="built_in">m_Key</span>(key) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getKey</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">derivedPrint</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; &quot;[Derived]: Dict is &#123; &quot; &lt;&lt; m_Value &lt;&lt; &quot;, &quot; &lt;&lt; getKey() &lt;&lt; &quot; &#125;&quot; &lt;&lt; std::endl; // 直接访问 private 成员，出现不可访问错误</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[Derived]: Dict is &#123; &quot;</span> &lt;&lt; <span class="built_in">getValue</span>() &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; <span class="built_in">getKey</span>() &lt;&lt; <span class="string">&quot; &#125;&quot;</span> &lt;&lt; std::endl; <span class="comment">// 通过 getValue 函数间接访问</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同名函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">who</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 多重继承</span></span><br><span class="line">    Derived derived;</span><br><span class="line">    derived.<span class="built_in">where</span>(); <span class="comment">// &gt;&gt; Here</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 限定作用域来指定调用子类还是父类的函数</span></span><br><span class="line">    derived.Derived::<span class="built_in">who</span>(); <span class="comment">// &gt;&gt; Derived</span></span><br><span class="line">    derived.Base::<span class="built_in">who</span>(); <span class="comment">// &gt;&gt; Base</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象切割问题</span></span><br><span class="line">    Base derived1 = <span class="built_in">Derived</span>();</span><br><span class="line">    Base* derived2 = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内存中 derived1、derived2 的数据如下：</p>
<p><em>derived1</em></p>
<p><img src= "/img/loading.gif" data-src="/images/derived1.png" alt="derived1"></p>
<p><em>derived2</em></p>
<p><img src= "/img/loading.gif" data-src="/images/derived2.png" alt="derived2"></p>
<h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><p>我们将<u>编译时</u>编译器根据对象的静态类型（即<strong>声明时的类型</strong>）决定函数的调用称之为<strong>静态绑定</strong>，而<strong>动态绑定</strong>则允许程序在<u>运行时</u>通过对象的<strong>实际类型</strong>来确定函数的调用。正因如此，动态绑定技术能够实现<strong>成员函数的重写</strong>。</p>
<p><strong>虚函数</strong>使用<u>虚函数表</u>和<u>虚表指针</u>来实现动态绑定。当父类拥有虚函数时，编译器会为子类和父类创建各自的虚函数表，其中存储指向虚函数的指针。运行期间，父类对象和子类对象中各自会保存一个指向自己虚表的虚表指针。函数调用时，会通过虚表指针查找虚表中对应的函数指针，如果是子类，找到的就会是指向子类重写方法的函数指针，从而实现动态绑定。</p>
<p>在 Java 中，只有在调用静态方法、私有方法和构造方法时才使用静态绑定；在 C++ 中，只有在调用虚函数时才使用动态绑定。因此，在 C++ 中，类的成员函数默认是不可被重写的，只有使用 <code>vitural</code> 修饰的虚函数才可以被子类重写。</p>
<p>使用 <code>override</code> （C++ 11）修饰子类中用于重写父类的函数，可以为这个函数提供一些语法等层面的检查，提升代码规范。</p>
<p><strong>我们应遵守一个原则：必须将父类的析构函数定义为虚函数</strong>。这样可以避免声明为父类类型的子类对象，在销毁时未调用子类的析构函数，导致内存泄漏。</p>
<blockquote>
<p><strong>备注：</strong></p>
<ol>
<li>C++ 中，拥有虚函数的类称为多态类。</li>
<li>引入虚函数映射表，会不可避免地产生少量的内存和运行开销。</li>
<li>虽然说是“重写”，其实没有真的覆盖父类的函数，是基于函数指针实现的重定向。</li>
</ol>
</blockquote>
<p>一个简单的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_Value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Base</span>()</span><br><span class="line">        : <span class="built_in">m_Value</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> value)</span><br><span class="line">        : <span class="built_in">m_Value</span>(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明为虚函数，允许重写</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[Base]: Value is &quot;</span> &lt;&lt; <span class="built_in">getValue</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明为虚函数，保证安全</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 声明重写，主要是提供代码检查</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[Derived]: Value is &quot;</span> &lt;&lt; <span class="built_in">getValue</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived* derived = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    derived-&gt;<span class="built_in">print</span>(); <span class="comment">// &gt;&gt; [Derived]: Value is 0</span></span><br><span class="line"></span><br><span class="line">    Base* base = <span class="keyword">new</span> <span class="built_in">Base</span>();</span><br><span class="line">    base-&gt;<span class="built_in">print</span>(); <span class="comment">// &gt;&gt; [Base]: Value is 0</span></span><br><span class="line"></span><br><span class="line">    Base* derivedToo = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    derivedToo-&gt;<span class="built_in">print</span>(); <span class="comment">// &gt;&gt; [Derived]: Value is 0</span></span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><p>纯虚函数<strong>没有函数实现</strong>。</p>
<p>一个类如果拥有纯虚函数，编译器就会认为它是抽象类，无法用来实例化，直到你重写纯虚函数。因此，纯虚函数可以用来<strong>要求子类必须重写它</strong>。</p>
<p>我们可以使用纯虚函数来<strong>设计抽象类和接口</strong>，实现面向对象编程。</p>
<p>一个简单的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_Value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Base</span>()</span><br><span class="line">        : <span class="built_in">m_Value</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> value)</span><br><span class="line">        : <span class="built_in">m_Value</span>(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明为纯虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 重写父类的纯虚函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[Derived]: Value is &quot;</span> &lt;&lt; <span class="built_in">getValue</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived* derived = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    derived-&gt;<span class="built_in">print</span>(); <span class="comment">// &gt;&gt; [Derived]: Value is 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Base* base = new Base(); // 无法再实例化</span></span><br><span class="line"></span><br><span class="line">    Base* derivedToo = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    derivedToo-&gt;<span class="built_in">print</span>(); <span class="comment">// &gt;&gt; [Derived]: Value is 0</span></span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组-array"><a href="#数组-array" class="headerlink" title="数组 array"></a>数组 array</h2><p>标准库中的数组 <code>std::array</code> 即是一个<strong>静态数组</strong>。</p>
<p>相比于原始数组：</p>
<ul>
<li><p>二者的数据都存储在<u>栈上</u>。</p>
</li>
<li><p>标准库中的数组可以<u>记录数组的大小</u>。</p>
</li>
<li><p>标准库中的数组拥有<u>迭代器</u>，支持 foreach 循环，同样支持标准库中提供的很多<u>集合操作函数</u>，如 <code>std::sort</code>。</p>
</li>
<li><p>标准库中的数组<u>支持宏</u>，比如设置 <code>ITERATOR_DEBUG_LEVEL</code> 可以实现<u>边界检查</u>。</p>
</li>
</ul>
<p><strong>我们应该遵守一个原则：尽可能使用标准库种的数组，代替原始数组。</strong></p>
<h2 id="向量-vector"><a href="#向量-vector" class="headerlink" title="向量 vector"></a>向量 vector</h2><h3 id="概念-6"><a href="#概念-6" class="headerlink" title="概念"></a>概念</h3><p>标准库中的向量 <code>std::vector</code> 即是一个<strong>动态数组</strong>。</p>
<p>向量为了支持动态扩容，它的数据存储在<strong>堆上</strong>。</p>
<h3 id="向量使用优化"><a href="#向量使用优化" class="headerlink" title="向量使用优化"></a>向量使用优化</h3><p>向量的默认容量是 <code>0</code>，每当我们放入一个新元素，它就会扩容一次，容量增加 <code>1</code>。</p>
<p>向量扩容的方法是在内部创建一个更大的数组，并把旧的数组复制给新数组，随着元素数量增多，扩容一次的开销也在变大。因此，在默认容量的情况下，往向量中不断放入新元素会导致越来越多的复制行为。所以，在使用向量时，<strong>我们应该遵守一个原则：提前设置足够大的容量，避免频繁扩容。</strong></p>
<p>当我们使用向量存放对象时，<code>push_back</code> 函数接收我们在容器外构造的对象，把它拷贝到容器中并销毁外面的对象；<code>emplace_back</code> 函数接收构造函数参数，在容器内构造对象。<code>push_back</code> 函数相较于 <code>emplace_back</code> 函数多了拷贝和销毁操作。所以，<strong>在使用向量存储对象时，我们应该遵守一个原则：使用 <code>emplace_back</code> 函数放入对象。</strong></p>
<p>一个简单的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">int</span> x)</span><br><span class="line">        : _x(x)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Constructed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">const</span> Entity&amp; other)</span><br><span class="line">        : _x(other._x)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Copied!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Entity</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Destroyed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;Entity&gt; vector;</span><br><span class="line">    vector.<span class="built_in">reserve</span>(<span class="number">10</span>); <span class="comment">// 增加容量到 10，避免扩容和复制</span></span><br><span class="line"></span><br><span class="line">    vector.<span class="built_in">push_back</span>(&#123; <span class="number">1</span> &#125;); <span class="comment">// &gt;&gt; Constructed! &gt;&gt; Copied! &gt;&gt; Destroyed!</span></span><br><span class="line">    vector.<span class="built_in">push_back</span>(&#123; <span class="number">2</span> &#125;);</span><br><span class="line">    vector.<span class="built_in">push_back</span>(&#123; <span class="number">3</span> &#125;);</span><br><span class="line">    vector.<span class="built_in">push_back</span>(&#123; <span class="number">4</span> &#125;);</span><br><span class="line">    vector.<span class="built_in">push_back</span>(&#123; <span class="number">5</span> &#125;);</span><br><span class="line"></span><br><span class="line">    vector.<span class="built_in">emplace_back</span>(<span class="number">1</span>); <span class="comment">// &gt;&gt; Constructed!</span></span><br><span class="line">    vector.<span class="built_in">emplace_back</span>(<span class="number">2</span>);</span><br><span class="line">    vector.<span class="built_in">emplace_back</span>(<span class="number">3</span>);</span><br><span class="line">    vector.<span class="built_in">emplace_back</span>(<span class="number">4</span>);</span><br><span class="line">    vector.<span class="built_in">emplace_back</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对组-pair-和元组-tuple"><a href="#对组-pair-和元组-tuple" class="headerlink" title="对组 pair 和元组 tuple*"></a>对组 pair 和元组 tuple*</h2><p>对组通常用于处理一组简单的二元数据，比如键值对。因为它的结构很简单，只包含两个成员(<code>first</code>和<code>second</code>)，所以在要快速创建一个二元数据容器时非常方便。</p>
<p>元组是一个通用的多元容器，可以包含任意多个不同类型的数据项，比对组更灵活。元组只能通过 <code>std::get&lt;index&gt;</code> 函数来访问元素，语法奇怪且可读性很低。</p>
<p>对组和元组都缺少明确且有意义的字段名称。在实际应用中，我们更应该<strong>使用类或结构体</strong>来代替元组和对组，保证代码的安全性和可读性。</p>
<h2 id="Lambda-函数"><a href="#Lambda-函数" class="headerlink" title="Lambda 函数"></a>Lambda 函数</h2><p>Lambda 匿名函数（C++ 11）是一种用来创建一个<strong>无名、一次性函数</strong>的方法，它实际上是一个<strong>闭包对象</strong>，只不过我们将其当作函数来使用。</p>
<p>Lambda 函数的创建需要上下文环境，它在运行时生成，作用于运行时，因此不能在<strong>全局作用域中</strong>创建。</p>
<p>Lambda 函数的<strong>创建语法</strong>是: <code>[捕获列表](参数列表) &#123; 函数体 &#125;</code>。</p>
<p>Lambda 函数<u>捕获列表</u>接受的值为：</p>
<ul>
<li><strong><code>=</code>：</strong>按值传递所有使用到的变量</li>
<li><strong><code>&amp;</code>：</strong>按引用传递所有使用到的变量</li>
<li><strong>指明使用的变量：</strong>按值传递</li>
<li><strong>指明使用的变量并在前使用 <code>&amp;</code> 操作符：</strong>按引用传递</li>
</ul>
<blockquote>
<p><strong>备注：</strong></p>
<p>原始函数指针只能接受无捕获列表的 Lambda 函数，对于有捕获列表的 Lambda 函数，我们应该使用 <code>std::function</code> 接收。</p>
</blockquote>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><h3 id="概念-7"><a href="#概念-7" class="headerlink" title="概念"></a>概念</h3><p>模板实质上是制定了一套规则，<strong>让编译器跟据规则生成代码</strong>。</p>
<p>模板的逻辑类似于宏定义，但它更加安全，也更晚发生。编译器会用每一个模板参数值替换模板参数，生成对应的结果，它可以使用在<strong>类、结构体和函数上</strong>。</p>
<p>模板本身并不会编译进可执行程序中，<strong>只有使用了模板</strong>，编译器才会跟据模板参数的值，生成符合的结果，例如函数定义、类声明等。MSVC 编译器甚至不会对模板中的代码进行语法检查。也由于这个特点，模板参数接受的值只能是编译时就确定的值，即<strong>常量表达式或类型名称</strong>。</p>
<p>模板参数的类型表示模板参数接受什么样的值，由于模板参数只接受编译时就确定的值，模板参数的类型就必须是<strong>任意在编译时可以确定值的数据类型和类型名称</strong>。</p>
<p><strong>我们应该遵守一个原则：不要编写过于复杂的模板代码，这会导致严重的代码阅读可读性问题。</strong></p>
<h3 id="模板函数"><a href="#模板函数" class="headerlink" title="模板函数"></a>模板函数</h3><p>一个简单的例子：</p>
<p><em>源代码</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型模板参数 T，即模板参数类型为类型名称（它接受的值是各种类型名称）</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>); <span class="comment">// 出现 int 类型的函数调用，模板参数值为 int，编译器将生成一个接收 int 类型参数的 print 函数</span></span><br><span class="line">    <span class="built_in">print</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(<span class="string">&quot;Hello!&quot;</span>); <span class="comment">// const char* 也是如此</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当编译器可以推断模板参数时，可以省略不写</span></span><br><span class="line">    print&lt;&gt;(<span class="number">1.0f</span>); </span><br><span class="line">    <span class="built_in">print</span>(<span class="number">2l</span>);</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>编译结果（模拟）</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器自动生成的四个 print 函数的定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">float</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">long</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello!&quot;</span>); </span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1.0f</span>); </span><br><span class="line">    <span class="built_in">print</span>(<span class="number">2l</span>);</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模板类"><a href="#模板类" class="headerlink" title="模板类"></a>模板类</h3><p>一个简单的例子：</p>
<p><em>源代码</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 非类型模板参数 N，模板参数类型为 int（它接受的值是 int 常量表达式）</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_Array[N];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSize</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Array&lt;<span class="number">5</span>&gt; array;</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>编译结果</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器生成的类声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_Array[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSize</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Array array;</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>作用域可以减少符号的命名冲突问题，然而对于需要提供给其它翻译单元使用的变量和函数来说，它们只能定义在全局作用域中。因此，当我们的项目使用了很多依赖库的时候，依赖库所提供的符号就很容易产生命名冲突。</p>
<p>C 语言的解决方案是为所有的符号增加一个唯一的前缀，如 GLFW 库中提供的函数 <code>glfwInit</code> 等就使用了库名称 glfw 作为前缀。这是一个不够直接的解决办法，因此 C++ 引入了命名空间。</p>
<p>命名空间是一种专门用来解决<strong>全局作用域中</strong>的<strong>符号命名冲突问题</strong>的作用域。命名空间将原先定义在全局作用域下的符号转移到其中，使用这些符号时要通过它来访问。</p>
<p>命名空间使用<strong>作用域解析运算符</strong>来解析指定命名空间下的符号，如 <code>std::cout</code>。</p>
<p>命名空间支持<u>嵌套</u>、<u>别名</u>和<u>内联</u>。</p>
<p><strong>我们应该遵守一个原则：不要滥用 <code>using namespace 具体命名空间</code> 和 <code>namespace 别名 = 具体命名空间</code>，否则命名空间的存在就失去了意义。</strong></p>
<p>一个简单的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> apple &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> orange &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span> </span>&#123;</span><br><span class="line">        std::string copy = message;</span><br><span class="line">        std::<span class="built_in">reverse</span>(copy.<span class="built_in">begin</span>(), copy.<span class="built_in">end</span>());</span><br><span class="line">        std::cout &lt;&lt; copy &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 嵌套的命名空间</span></span><br><span class="line">    <span class="keyword">namespace</span> correct &#123;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内联的命名空间中的符号可以直接访问，相当于没有命名空间（雾）</span></span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">namespace</span> justhello &#123;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">just_hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Hello?&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    apple::<span class="built_in">print</span>(<span class="string">&quot;Apple!&quot;</span>);</span><br><span class="line">    orange::<span class="built_in">print</span>(<span class="string">&quot;Orange!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问嵌套的命名空间</span></span><br><span class="line">    orange::correct::<span class="built_in">print</span>(<span class="string">&quot;Orange Correct!&quot;</span>);</span><br><span class="line">    <span class="comment">// 为命名空间起别名</span></span><br><span class="line">    <span class="keyword">namespace</span> orangecrt = orange::correct;</span><br><span class="line">    orangecrt::<span class="built_in">print</span>(<span class="string">&quot;Orangecrt!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内联的命名空间中的符号可以直接访问，相当于没有命名空间（雾）</span></span><br><span class="line">    orange::<span class="built_in">just_hello</span>();</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p><code>static</code> 关键字有三种作用，取决于用在<u>全局变量或函数上</u>，在<u>局部变量上</u>，还是在<u>成员变量或函数上</u>。</p>
<p><strong>静态变量</strong>有几个共通点：</p>
<ul>
<li>无论哪种静态变量，都存储在<u>数据段</u>上，而不是栈上。</li>
<li>静态变量<u>只初始化一次</u>，即使是局部静态变量，再局部代码块再次执行时也不会再初始化。</li>
<li>静态变量的生命周期为整个程序运行周期。</li>
</ul>
<p>静态变量的具体作用域、生命周期和内存位置<a href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%86%85%E5%AD%98%E4%BD%8D%E7%BD%AE-0">前文</a>已有，在此不做赘叙。</p>
<h3 id="静态全局变量-静态函数"><a href="#静态全局变量-静态函数" class="headerlink" title="静态全局变量&#x2F;静态函数"></a>静态全局变量&#x2F;静态函数</h3><p>在全局变量或函数上使用 <code>static</code>，被修饰的全局变量或函数将具有<strong>内部链接性</strong>，即在链接时将<strong>只对同一个目标文件的成员可见</strong>。</p>
<p><strong>我们应该遵守一个原则：一个全局变量或函数除非需要跨翻译单元链接，否则应该使用 <code>static</code> 修饰，避免方式不必要的错误。</strong></p>
<p>一个简单的例子：</p>
<p><em>Main.cpp</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Log(x) std::cout &lt;&lt; x &lt;&lt; std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -- 定义静态全局变量，在 Static.cpp 中也定义有同名静态全局变量，不会出现多重定义错误 --</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> staticVar = <span class="number">11</span>;</span><br><span class="line"><span class="comment">// -- 定义非静态全局变量，在 Static.cpp 中也定义有同名非静态全局变量，出现多重定义错误 --</span></span><br><span class="line"><span class="comment">// int commonVar = 33;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -- 静态全局变量不允许使用 extern 修饰，不能单独声明 --</span></span><br><span class="line"><span class="comment">// -- 声明非静态全局变量，定义在 Static.cpp 中 --</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> commonVar;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -- 声明静态函数，定义在 Static.cpp 中 --</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">staticFunction</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// -- 声明非静态函数，同样定义在 Static.cpp 中 --</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">commonFunction</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// -- 表明静态全局变量的定义只对同一个翻译单元的成员可见 --</span></span><br><span class="line">    <span class="comment">// 输出的是 Main.cpp 自己定义的 staticVar，值为 11</span></span><br><span class="line">    <span class="built_in">Log</span>(staticVar);</span><br><span class="line">    <span class="comment">// 输出的是 Static.cpp 中定义的 commonVar，值为 44</span></span><br><span class="line">    <span class="built_in">Log</span>(commonVar);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -- 表明静态函数的定义只对同一个翻译单元的成员可见 --</span></span><br><span class="line">    <span class="comment">// 出现未定义错误</span></span><br><span class="line">    <span class="comment">// staticFunction();</span></span><br><span class="line">    <span class="comment">// 正常链接到 Static.cpp 中函数 commonFunction 的定义</span></span><br><span class="line">    <span class="built_in">commonFunction</span>();</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>Static.cpp</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Log(x) std::cout &lt;&lt; x &lt;&lt; std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> staticVar = <span class="number">22</span>;</span><br><span class="line"><span class="type">int</span> commonVar = <span class="number">44</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">staticFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Log</span>(<span class="string">&quot;This is a static function outside class and struct.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">commonFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Log</span>(<span class="string">&quot;This is a common function outside class and struct.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="静态局部变量"><a href="#静态局部变量" class="headerlink" title="静态局部变量"></a>静态局部变量</h3><p>在局部变量上使用 <code>static</code>，被修饰的局部变量的生命周期将会延长至<strong>整个程序运行周期</strong>，但<strong>作用域不变</strong>。</p>
<p>一个简单的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">// 存储在静态存储区</span></span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(); <span class="comment">// 第一次调用，i 初始化为 0，后续不再初始化</span></span><br><span class="line">    <span class="built_in">print</span>();</span><br><span class="line">    <span class="built_in">print</span>();</span><br><span class="line">    <span class="built_in">print</span>();</span><br><span class="line">    <span class="built_in">print</span>();</span><br><span class="line">    <span class="comment">// 输出结果为：0 1 2 3 4</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找不到 i 的定义</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; std::endl;</span></span><br><span class="line">    </span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="静态成员变量-静态成员函数"><a href="#静态成员变量-静态成员函数" class="headerlink" title="静态成员变量&#x2F;静态成员函数"></a>静态成员变量&#x2F;静态成员函数</h3><p>在成员变量或成员函数上使用 <code>static</code>，其行为与 Java 中在成员变量或成员函数上使用 <code>static</code> 一致，被修饰的成员变量或成员函数将<strong>被类或结构体的所有实例共享</strong>。</p>
<p>静态成员变量必须在类或结构体外单独定义，详见<a href="#%E5%AE%9E%E4%BE%8B%E5%8C%96">前文</a>。</p>
<p>一个简单的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StaticClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 声明类存在静态成员变量 staticVar，这个变量将被类的所有实例共享</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> staticVar;</span><br><span class="line">    <span class="comment">// 声明类存在非静态成员变量 commonVar</span></span><br><span class="line">    <span class="type">int</span> commonVar;</span><br><span class="line">    <span class="comment">// 定义类的静态成员函数 staticPrint，这个函数将被类的所有实例共享</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">staticPrint</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; staticVar &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 定义类的非静态成员函数 commonPrint</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">commonPrint</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; commonVar &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 必须在类外定义静态成员变量 staticVar</span></span><br><span class="line"><span class="type">int</span> StaticClass::staticVar;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	<span class="comment">// 创建实例，同时创建成员变量 commonVar</span></span><br><span class="line">    StaticClass staticClass1;</span><br><span class="line">    staticClass1.staticVar = <span class="number">11</span>;</span><br><span class="line">    staticClass1.commonVar = <span class="number">22</span>;</span><br><span class="line"></span><br><span class="line">    StaticClass staticClass2;</span><br><span class="line">    staticClass2.staticVar = <span class="number">33</span>;</span><br><span class="line">    staticClass2.commonVar = <span class="number">44</span>;</span><br><span class="line"></span><br><span class="line">    staticClass1.<span class="built_in">staticPrint</span>(); <span class="comment">// 输出结果为 33;</span></span><br><span class="line">    staticClass1.<span class="built_in">commonPrint</span>(); <span class="comment">// 输出结果为 22;</span></span><br><span class="line">    staticClass2.<span class="built_in">staticPrint</span>(); <span class="comment">// 输出结果为 33;</span></span><br><span class="line">    staticClass2.<span class="built_in">commonPrint</span>(); <span class="comment">// 输出结果为 44;</span></span><br><span class="line">    </span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="const-关键字"><a href="#const-关键字" class="headerlink" title="const 关键字"></a>const 关键字</h2><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p><code>const</code> 关键字有两种作用，取决于用在<u>变量上</u>，还是在<u>成员函数声明后</u>。</p>
<h3 id="常量-1"><a href="#常量-1" class="headerlink" title="常量"></a>常量</h3><p>在变量上使用 <code>const</code>，被修饰的变量将成为一个<strong>常量变量</strong>，在初始化后不允许修改，用于运行时确定的常量。</p>
<p>特别地，常量对象除不能再赋值外，也只允许调用他们的<strong>只读函数</strong>。</p>
<p><strong>我们应该遵守一个原则：对于一个不需要被修改的变量，我们设置让它为常量，避免意外修改，提升代码安全性。</strong></p>
<p>一个简单的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> sum1 = <span class="built_in">add1</span>(<span class="number">5</span>, <span class="number">10</span>); <span class="comment">// sum1 赋值为 15 后，不允许修改</span></span><br></pre></td></tr></table></figure>

<h3 id="只读成员函数"><a href="#只读成员函数" class="headerlink" title="只读成员函数"></a>只读成员函数</h3><p>在成员函数声明后使用 <code>const</code>，被修饰的函数将<strong>不允许对成员变量进行修改</strong>（除非这个成员变量使用 <code>mutable</code> 修饰为可修改），成为一个<strong>只读函数</strong>。</p>
<p>这个用法可以提升代码的安全性和规范性。</p>
<p>在使用常量对象或常量对象的引用时，编译器会要求我们只能使用它的只读函数。</p>
<p>一个简单的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_X, m_Y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// m_X = 10; // 不允许</span></span><br><span class="line">        <span class="keyword">return</span> m_X;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> Entity entity;</span><br><span class="line">    entity.<span class="built_in">getX</span>(); <span class="comment">// 如果没有使用 const 修饰 getX 函数，则不允许调用 getX 函数</span></span><br><span class="line">    </span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="extern-关键字"><a href="#extern-关键字" class="headerlink" title="extern 关键字**"></a>extern 关键字**</h2><h3 id="外部变量"><a href="#外部变量" class="headerlink" title="外部变量"></a>外部变量</h3><p>一个简单的例子：</p>
<p><em>Main.cpp</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明 externInt 变量存在于其它翻译单元，允许对它的使用</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> externInt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用</span></span><br><span class="line">    externInt++;</span><br><span class="line">    std::cout &lt;&lt; externInt &lt;&lt; std::endl; <span class="comment">// &gt;&gt; 11</span></span><br><span class="line">    </span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>Extern.cpp</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// externInt 变量的定义</span></span><br><span class="line"><span class="type">int</span> externInt = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h2 id="mutable-关键字"><a href="#mutable-关键字" class="headerlink" title="mutable 关键字"></a>mutable 关键字</h2><h3 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h3><p><code>mutable</code> 关键字有两种作用，取决于用在<u>成员变量上</u>，还是在 <u>Lambda 函数上</u>。</p>
<h3 id="可改变成员变量"><a href="#可改变成员变量" class="headerlink" title="可改变成员变量"></a>可改变成员变量</h3><p>在成员变量上使用 <code>mutable</code>，主要用于调用一个只读成员函数时，需要对调用次数进行计数的调试场合，它允许被修饰的成员变量<strong>在只读成员函数中改变值</strong>。除非必要，不建议这样使用。</p>
<p>一个简单的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_X, m_Y;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> m_DebugCount = <span class="number">0</span>; <span class="comment">// 允许在只读函数中修改</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_DebugCount++; <span class="comment">// 自增计数</span></span><br><span class="line">        <span class="keyword">return</span> m_X;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> Entity entity;</span><br><span class="line">    entity.<span class="built_in">getX</span>();</span><br><span class="line">    </span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可改变的-Lambda-函数捕获变量"><a href="#可改变的-Lambda-函数捕获变量" class="headerlink" title="可改变的 Lambda 函数捕获变量"></a>可改变的 Lambda 函数捕获变量</h3><p>在 Lambda 函数上使用 <code>mutable</code>，主要用于让 Lambda 函数中<strong>按值传递方式捕获的变量变得可以修改</strong>。这种使用场景相对更多。</p>
<p>一个简单的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> fun = [=]() <span class="keyword">mutable</span></span><br><span class="line">        &#123;</span><br><span class="line">            x++; <span class="comment">// 使 x 可以自增</span></span><br><span class="line">            std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fun</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; std::endl; <span class="comment">// 不会修改外部的 x，因为按值传递</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="explicit-关键字"><a href="#explicit-关键字" class="headerlink" title="explicit 关键字"></a>explicit 关键字</h2><h3 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a>作用</h3><p><code>explicit</code> 关键字用在<u>构造函数</u>上，用于<u>禁止编译器进行隐式构造函数转换</u>。</p>
<h3 id="禁止隐式构造函数类型转换"><a href="#禁止隐式构造函数类型转换" class="headerlink" title="禁止隐式构造函数类型转换"></a>禁止隐式构造函数类型转换</h3><p>C++ 编译器允许代码隐式地进行一次类型转换。<u>隐式构造函数类型转换</u>是指类或结构体类型的变量可以<u>直接使用构造函数所接受的参数赋值</u>，这会隐式的调用它的构造函数，实现类型转换。</p>
<p>这种转换可能造成代码阅读困难等问题。因此，在必要时可以使用 <code>explicit</code> 来禁止。</p>
<p>一个简单的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name)</span><br><span class="line">        : <span class="built_in">name</span>(name), <span class="built_in">age</span>(<span class="number">-1</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止隐式构造函数转换</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Person</span><span class="params">(<span class="type">int</span> age)</span></span></span><br><span class="line"><span class="function">        : name(<span class="string">&quot;Unknown&quot;</span>), age(age) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">short</span> aShort = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> anInt = aShort; <span class="comment">// 隐式类型转换</span></span><br><span class="line"></span><br><span class="line">    Person person1 = std::<span class="built_in">string</span>(<span class="string">&quot;Miya&quot;</span>); <span class="comment">// 隐式构造函数转换，使用了 Person 类的构造函数 Person(const std::string&amp; name)</span></span><br><span class="line">    <span class="comment">// Person person2 = 18;  // 隐式构造函数转换失败，没有参数匹配的构造函数</span></span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="外部库"><a href="#外部库" class="headerlink" title="外部库"></a>外部库</h2><h3 id="概念-8"><a href="#概念-8" class="headerlink" title="概念"></a>概念</h3><p>外部库文件分为<u>静态链接库</u> <code>.lib</code> 或 <code>.a</code> 和<u>动态链接库</u> <code>.dll</code>、<code>.so</code> 或 <code>.dylib</code>。</p>
<h3 id="静态链接库"><a href="#静态链接库" class="headerlink" title="静态链接库"></a>静态链接库</h3><p>静态链接库文件在<strong>编译时发生</strong>，即在编译过程中将库文件链接到可执行文件（或一个动态链接库），在程序运行时作为一个整体一起被装入内存使用。</p>
<p>静态链接所使用的静态链接库文件中包含了所有的<strong>符号和定义</strong>。</p>
<p>使用 Visual Studio 构建项目时，加载<strong>预编的译静态链接库</strong>的设置比较麻烦，基本步骤如下：</p>
<ol>
<li><strong>下载库文件：</strong>下载官方提供的预编译的库文件，放入解决方案的 <code>Dependencies/库名称</code> 目录下（为了项目的规范性），库文件必须与项目的目标平台&#x2F;使用的工具链一致&#x2F;兼容。</li>
<li><strong>添加附加包含目录：</strong>项目属性设置“C&#x2F;C++ -&gt; 常规 -&gt; 附加包含目录”添加上头文件所在目录。</li>
<li><strong>添加附加库目录：</strong>项目属性设置“链接器 -&gt; 常规 -&gt; 附加库目录”添加上库文件所在目录。</li>
<li><strong>添加附加依赖项：</strong>项目属性设置“链接器 -&gt; 输入 -&gt; 附加依赖项”添加上要加载的静态库文件。</li>
</ol>
<p>使用 Visual Studio 构建项目时，加载拥有源码可以<strong>自己编译的静态链接库</strong>的基本步骤如下：</p>
<ol>
<li><strong>添加库项目：</strong>取得库项目源码，并将库项目添加到解决方案中。</li>
<li><strong>添加附加包含目录：</strong>项目属性设置“C&#x2F;C++ -&gt; 常规 -&gt; 附加包含目录”添加上库项目的头文件所在目录。</li>
<li><strong>添加引用：</strong>右键项目“添加 -&gt; 引用”，选择库项目并确定。</li>
</ol>
<h3 id="动态链接库"><a href="#动态链接库" class="headerlink" title="动态链接库"></a>动态链接库</h3><p>动态链接库文件在<strong>运行时发生</strong>，即在程序运行过程中动态地查找和链接库文件，将库文件装入内存使用。</p>
<p>动态链接所使用的动态链接库文件中包含了所有的<strong>符号和定义</strong>。</p>
<p>使用 Visual Studio 构建项目时，链接<strong>预编译的动态链接库</strong>的基本步骤如下：</p>
<ol>
<li><strong>加载导入库：</strong>采用与静态链接相同的步骤（步骤 1~4），加载对应的导入库。</li>
<li><strong>添加动态链接库文件</strong>：将动态链接库文件放置在可执行程序的同级目录下，这是动态链接库的默认搜索路径，程序运行时会在这个路径下自动搜索需要的动态链接库并将其装入内存。若库文件位于不同路径，可以设置系统环境变量 <code>PATH</code> 或者在代码中指定动态链接库的路径。</li>
</ol>
<blockquote>
<p><strong>备注：</strong></p>
<p>在 Windows 平台上，动态链接库有对应的导入库（静态链接库）文件，其中包含了符号信息，链接器使用这个导入库解析符号，以确定运行时需要加载哪个动态链接库，同时把可执行文件可以链接到导入库中的符号，运行时由系统的加载器再去加载符号定义。</p>
</blockquote>
<h3 id="静态链接与动态链接的比较"><a href="#静态链接与动态链接的比较" class="headerlink" title="静态链接与动态链接的比较"></a>静态链接与动态链接的比较</h3><ul>
<li>使用<strong>静态链接</strong>的方式，库文件将和可执行文件打包在一起，编译器和链接器知道程序实际需要链接的符号定义，因此可以对链接过程做优化，但可执行文件的体积相对更大。</li>
<li>使用<strong>动态链接</strong>的方式，库文件单独存在于系统中，可执行文件的体积相对较小，支持不同程序共享同一份库，在运行时只需要装入一份库文件，可以节省内存空间，但在链接的过程中，有很多优化策略无法执行。</li>
</ul>
<h2 id="栈与堆内存的比较"><a href="#栈与堆内存的比较" class="headerlink" title="栈与堆内存的比较"></a>栈与堆内存的比较</h2><p>C++ 有两种可以由编程人员主动申请的常用内存类型，<strong>堆和栈</strong>，他们的核心区别如下：</p>
<ul>
<li><p><strong>内存大小不同：</strong>栈内存的大小通常是<u>固定的</u>，取决于操作系统和编译器的配置；堆内存虽然也有默认大小，但它<u>可以动态变化</u>，随程序运行而改变。</p>
</li>
<li><p><strong>内存申请语法不同：</strong>栈内存的申请语法为<u>定义变量</u>，在<u>编译时就确定了申请的内存大小</u>；堆内存的申请方式为使用 <code>new</code> 关键字<u>在运行时动态申请内存空间</u>。</p>
</li>
<li><p><strong>内存分配方式不同：</strong>栈内存是<u>连续的</u>，通过栈顶指针的移动来分配和释放内存，分配简单且快速；堆内存<u>不是连续的</u>，散布在内存中各个地方，分配时会调用 allocate 函数，然后调用系统底层函数，执行空闲列表检查、内存请求、分配情况记录等操作，过程复杂且慢，是堆内存使用起来慢的<u>第一因素</u>。</p>
</li>
<li><p><strong>内存释放方式不同：</strong>栈内存在其作用域结束时会<u>自动弹出栈释放</u>；堆内存需要使用 <code>delete</code> 关键字<u>手动释放</u>，释放时同样需要做复杂的操作，是堆内存使用起来慢的<u>第二因素</u>。</p>
</li>
<li><p><strong>性能不同：</strong>栈内存的分配和释放都比堆内存快速，且栈内存因为其连续性，操作系统能够更有效地使用缓存。</p>
</li>
</ul>
<p><strong>我们应该遵守一个原则：尽可能使用栈内存。</strong>使用堆内存的唯一原因是我们无法使用栈内存实现，例如我们需要<u>生命周期比作用域大的变量</u>，或是我们需要<u>存储一个特别大的数据</u>，例如一个超过 50 MB 的纹理图案。</p>
<blockquote>
<p><strong>备注：</strong></p>
<p>栈内存和堆内存实际都位于计算机的 RAM 中，只不过栈内存因为其连续性，可以一起放入 CPU 缓存线上，能减少缓存未命中的情况，适用于高频使用的变量、函数等；堆内存因为其不连续性，更容易产生缓存未命中。当然，少量的缓存未命中不会在宏观层面拖慢程序的运行速度。</p>
</blockquote>
<h2 id="类型双关（原始内存操作）"><a href="#类型双关（原始内存操作）" class="headerlink" title="类型双关（原始内存操作）"></a>类型双关（原始内存操作）</h2><p>使用 C++ 我们可以实现对内存的直接操作。操作栈内存，我们只需要将一个栈上的变量转换为指针，此后转换成我们想要的类型的指针，即可<strong>把一种类型的变量当作另一种类型对待</strong>，绕过类型系统。</p>
<p>把一种类型的变量当作另一种类型对待，这就是<strong>类型双关</strong>。</p>
<p>需要注意，这样的原始内存操作<strong>非常危险</strong>，同时要注意内存的大小是否相等，避免访问不属于自己的内存。</p>
<p>一个简单的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 二者指向内存中的同一块地方，且把这块内存当作不同类型对待</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> aLong = <span class="number">10L</span>; <span class="comment">// &gt;&gt; 0a 00 00 00 00 00 00 00</span></span><br><span class="line">    <span class="type">double</span>&amp; aDouble = *((<span class="type">double</span>*)&amp;aLong); <span class="comment">// &gt;&gt; 0a 00 00 00 00 00 00 00</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// &gt;&gt; aDouble：00 00 00 00 00 00 f0 3f，即 1.0</span></span><br><span class="line">    <span class="comment">// &gt;&gt; aLong：00 00 00 00 00 00 f0 3f，即 460 7182 4188 0001 7408</span></span><br><span class="line">    aDouble = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="联合体"><a href="#联合体" class="headerlink" title="联合体"></a>联合体</h2><p>联合体和结构体一样，唯一区别是它的<strong>所有成员变量共享一块内存</strong>。</p>
<p>由于它的特点，我们可以很方便地用它来<strong>实现类型双关</strong>。相较于原始内存操作，这种方式实现的类型双关更加安全。</p>
<p>当一个联合体中有多个成员变量时，联合体只占用所有成员变量中最大的内存大小。</p>
<blockquote>
<p><strong>备注：</strong></p>
<p>在类中，匿名的类、结构体和联合体，只承载了组织成员的功能，不会限定成员的作用域。</p>
</blockquote>
<p>一个简单的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设我们只有一个处理 Vector2 的函数</span></span><br><span class="line"><span class="comment">// 但我们想要用它处理 Vector4</span></span><br><span class="line"><span class="comment">// 我们可以将 Vector4 当作两个 Vector2</span></span><br><span class="line"><span class="comment">// 使用匿名联合体实现这种类型双关</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector2</span> &#123;</span><br><span class="line">    <span class="type">float</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector4</span> &#123;</span><br><span class="line">    <span class="comment">// 匿名联合体，让其内成员变量共享一块内存</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="comment">// 使用匿名结构体来组织数据，把 x，y，z，w 打包成匿名联合体的一个匿名成员变量</span></span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            <span class="type">float</span> x, y, z, w;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 第二个匿名成员变量，存储两个 Vector2 a，b</span></span><br><span class="line">        <span class="comment">// 此后 Vector2 a、b 和 x、y、z、w 共享同一块 16 字节的内存</span></span><br><span class="line">        <span class="comment">// 使得 a.x == Vector4.x，b.x == Vector4.z ……</span></span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            Vector2 a, b;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_vector2</span><span class="params">(<span class="type">const</span> Vector2&amp; vector2)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; vector2.x &lt;&lt; <span class="string">&quot;, y: &quot;</span> &lt;&lt; vector2.y &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Vector4 vector4 = &#123; <span class="number">1.0f</span>, <span class="number">2.0f</span>, <span class="number">3.0f</span>, <span class="number">4.0f</span> &#125;;</span><br><span class="line">    <span class="built_in">print_vector2</span>(vector4.a); <span class="comment">// &gt;&gt; x: 1, y: 2</span></span><br><span class="line">    <span class="built_in">print_vector2</span>(vector4.b); <span class="comment">// &gt;&gt; x: 3, y: 4</span></span><br><span class="line"></span><br><span class="line">    vector4.y = <span class="number">5.0f</span>; <span class="comment">// 我们可以直接修改成员变量 x、y、z、w </span></span><br><span class="line">    vector4.b = &#123; <span class="number">9.0f</span>, <span class="number">12.0f</span> &#125;; <span class="comment">// 也可以直接修改 Vector2 类型的成员变量 a、b</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;==============================================&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print_vector2</span>(vector4.a); <span class="comment">// &gt;&gt; x: 1, y: 5</span></span><br><span class="line">    <span class="built_in">print_vector2</span>(vector4.b); <span class="comment">// &gt;&gt; x: 9, y: 12</span></span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>
        
          <div class="post-copyright">
                  <div class="copyright-item">
                      <span> 作者: Lyana-nullptr</span>
                  </div>
                  <div class="copyright-item">
                      <span> 链接: <a href="http://lyana-nullptr.github.io/2024/10/29/cpp-rush-planing/">http://lyana-nullptr.github.io/2024/10/29/cpp-rush-planing/</a></span>
                  </div>
                  <div class="copyright-item">
                      <span> 声明: 本博客所有文章除特别声明外，均采用许可协议 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> 转载请注明出处！</span>
                  </div>
          </div>
        
  </div>

  <div class="share-reward">
    <div class="share">
        
<div class="social-share" data-sites="facebook,twitter,wechat,weibo,qq"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css">
<script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script>


      </div>
        <div class="reward">
          
        </div>
    </div>
    
    <div class="post_tags">
      
        <i class="fas fa-tag"></i> <a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" class="tag">编程语言</a>
      
        <i class="fas fa-tag"></i> <a href="/tags/C/" class="tag">C++</a>
      
    </div>
    <div class="post-nav">
      
      
        <div class="post-nav-next post-nav-item">
            <a href="/2024/07/27/try-the-template-of-010editor/" >浅尝 010 Editor 的模板编写<i class="fa fa-chevron-right"></i></a>
        </div>
      
    </div>
      




</article>

    
<a id="gotop" href="javascript:" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    






    
<div id="bottom-outer">
    <div id="bottom-inner">
        © 2024 <i class="fa fa-heart" id="heart"></i> Lyana-nullptr
        <br>
        Powered by
        <a target="_blank" rel="noopener" href="http://hexo.io">hexo</a> | Theme is <a target="_blank" rel="noopener" href="https://github.com/a2396837/hexo-theme-blank/">blank</a>
        
          <div class="icp-info">
            
          <a href="" target="_blank"> </a>
        </div>
        
    </div>
  </div>
  
<script src="https://cdn.jsdelivr.net/npm/layui-src@2.5.5/dist/layui.min.js"></script>



  
    <script src="/js/script.js"></script>
  
    <script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script>
  

 



  <script>
    window.lazyLoadOptions = {
      elements_selector: 'img',
      threshold: 0
    }
</script>
<script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script>   
  


  <script>
    var images = $('img').not('.nav-logo img').not('.card img').not($('a>img')).not('.reward-content img')
    images.each(function (i, o) {
      var lazyloadSrc = $(o).attr('data-src') ? $(o).attr('data-src') : $(o).attr('src')
      $(o).wrap(`<a href="${lazyloadSrc}" data-fancybox="group" data-caption="${$(o).attr('alt')}" class="fancybox"></a>`)
    })
  </script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script>
  <script>
        $().fancybox({
      selector: '[data-fancybox]',
      loop: true,
      transitionEffect: 'slide',
      protect: true,
      buttons: ['slideShow', 'fullScreen', 'thumbs', 'close']
    })
  </script>   
  


  <script>
  if (!window.MathJax) {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]],
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
              const display = !!node.type.match(/; *mode=display/)
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
              const text = document.createTextNode('')
              node.parentNode.replaceChild(text, node)
              math.start = {node: text, delim: '', n: 0}
              math.end = {node: text, delim: '', n: 0}
              doc.math.push(math)
            }
          }, '']
        }
      }
    }
    
    var script = document.createElement('script')
    script.src = "https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js"
    script.id = 'MathJax-script'
    script.async = true
    document.head.appendChild(script)
  } else {
    MathJax.startup.document.state(0)
    MathJax.texReset()
    MathJax.typeset()
  }
  </script>
  


  
<script>
if (document.getElementsByClassName('mermaid').length) {
    if (window.mermaidJsLoad) mermaid.init()
    else {
      $.getScript("https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js", function () {
        window.mermaidJsLoad = true
        mermaid.initialize({
          theme: "default",
        })
      })
    }
  }
  </script>
  






  <script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script>
  


  <script src="https://cdn.jsdelivr.net/gh/a2396837/CDN@latest/js/firework.js"></script>
  


  
<script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js"></script>
<script>
!function (e, t, a) {
  var initCopyCode = function(){
    var copyHtml = '';
    copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
    copyHtml += '  <i class="fa fa-clipboard"></i><span>复制</span>';
    copyHtml += '</button>';
    $(".highlight .code pre").before(copyHtml);
    new ClipboardJS('.btn-copy', {
      target: function(trigger) {
        return trigger.nextElementSibling;
      }
    });
  }
  initCopyCode();
}(window, document);
</script>  
  

<script>
  var btntop = $('#gotop');
  btntop.on('click', function (e) {
    e.preventDefault();
    $('html, body').animate({ scrollTop: 0 }, '300');
  });

  var $table = $('.content table').not($('figure.highlight > table'))
$table.each(function () {
  $(this).wrap('<div class="table-wrap"></div>')
})
</script>



</html>